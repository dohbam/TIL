### 1. 왜 C를 배워야 하나요?

#### 1) C언어의 탄생과 역사

* C언어의 탄생
  * 1970년대 초 Unix 운영체제 개발
  * CPU에 종속적인 어셈블리 언어로 만들어짐
  * 하드웨어 제어와 프로그램 작성이 용이한 고급 언어 필요
  * C언어 탄생
  * Unix 운영체제의 90% 이상 C언어로 대체
  * Unix 운영체제를 다양한 컴퓨터 기종에 쉽게 이식
  * 만약 C언어가 개발되지 못했다면?
    * Unix 운영체제는 현재까지 남아있지 못했을 것
    * Linux나 MS-Window 운영체제도 존재하지 않았을 것
* 프로그래밍 언어의 종류
  * 저급 언어
    * 컴퓨터의 CPU가 해석하기 쉽게 만들어진 프로그래밍 언어
    * CPU 종속적
    * 예) Intel i7 Processor 기반의 어셈블리 프로그램
  * 고급 언어
    * 사람이 해석하기 쉽게 만들어진 프로그램
    * 절차적 언어: BASIC, COBOL, FORTRAN
    * 구조적 언어: PASCAL, C
    * 객체지향 언어: C++, JAVA, C#, Visual Basic, .NET
* C언어의 역사
  * `ALGOL60`: 구조화된 프로그래밍 언어의 효시
  * `CPL`: Combined Programming Language
  * `BCPL`: Basic CPL
  * `B Language`: Unix 운영체제 개발자인 켄 톰슨이 발전시킴
    * 바이트 처리가 지원되지 않아 Unix 운영체제에 이용 불가
  * `C Language`: 바이트처리, 구조체 지원 등이 추가되며 1972년 탄생
* C언어의 사용
  * 운영체제 기술
  * 하드웨어 제어
  * 시스템 프로그램
  * 일반 응용프로그램
* C언어의 특징
  * 시스템 기반의 프로그램 작성에 적합한 언어
    * 비트 단위 연산 가능
    * 포인터를 이용한 메모리에 대한 접근 용이
    * 자료 형 변환 자유로움
    * 여러 기종간 이식성 뛰어남
  * 범용 프로그램 작성에 적합한 언어
    * 풍부한 자료형 지원과 다양한 연산자 제공
    * 구조적 프로그램 언어로 모듈(함수) 방식 제어 구조
    * 다양한 라이브러리 제공
    * 동적 메모리를 활용한 효율적인 자료 처리
  * 저급 프로그래밍 언어와 고급 프로그래밍 언어의 양면성
    * 어셈블리 언어와의 연동 가능
    * 하드웨어 최적화된 프로그램 가능
  * 간결한 구조의 언어이면서도 정확한 제어 구조와 자료형 표현
* C언어의 발전과정
  * 각자 정한 C언어 표준으로 서로 호환 불능
  * 1983년 미국국가표준협회에서 ANSI C 발표
  * 현재 모든 C컴파일러는 ANSI C 표준안에 맞추어 작성되고 있음
    * `컴파일러`: 고급 언어로 작성된 프로그램을 컴퓨터가 실행할 수 있는 파일, 즉 기계어 코드로 변환해주는 도구
  * `C++` : 객체 지향 개념의 확장
  * `C#` : 구조의 단순화, 객체지향 개념의 확장, Microsoft사에서 개발
  * `JAVA` : 구조의 단순화, 객체지향 개념의 확장, 플랫폼과 독립적으로 개발

#### 2) C언어의 활용 사례

* 운영체제의 핵심, 커널
  * CPU, 메모리, 하드디스크 등과 같은 하드웨어 자원을 관리하는 커널
  * Unix, Linux 데스크탑, MS Window 데스크탑 각 운영체제의 커널도 C언어로 작성(.c 파일 확인 가능)
* 임베디드 시스템, 하드웨어 제어
  * 저급언어와 고급언어의 특성을 포함한 C언어
    * 저급언어: 하드웨어를 제어하기 쉬움
    * 각종 장치들의 지능화로 좀 더 정밀하고 고도화된 하드웨어 제어 프로그램 필요 - C언어 필수
  * 대표적인 DVR, CCTV 및 공장 자동화 장비, 진료용 장비, 군용장비 등 산업계의 많은 장비들이 C언어를 이용한 프로그램으로 제어됨
* 시스템 기반의 프로그램, 웹 서버
  * 운영체제에서 제공하는 기능은 API로 구현
  * API는 C언어의 함수로 구성
  * 시스템 기반 프로그램들은 C프로그램으로 작성하는 것이 최적
  * Apache 웹 서버, FTP 서버, 텔넷 서버 등 C언어로 작성
  * 온라인 게임 서버와 같이 속도에 민감한 프로그램 C언어로 작성
  * 보안 관련 프로그램이나 컴파일러와 같은 시스템 의존적인 작업

#### 3) C 프로그램의 개발 환경

* C 프로그램의 개발 과정
  * 소스코드 작성 및 수정
    * 소스코드 편집기를 이용하여 C언어 문법에 맞는 프로그램 작성
    * 소스파일명은 반드시 `.c` 확장자
  * 컴파일 & 링킹
    * C 컴파일러를 통해 소스 코드의 문제점을 확인
      * 정상적으로 컴파일되면 오브젝트 파일 생성
    * 링커에 의해 오브젝트 파일을 실행 가능한 실행파일로 링크
      * MS윈도우: 실행파일명 확장자 `.exe`
      * Linux 및 Unix: 샐행파일명 확장자 붙지 않음
  * 테스트
    * 컴파일&링크 과정에서 생성한 실행 파일이 설계대로 수행되는지 시험
  * 디버깅
    * 테스트과정에서 설계대로 동작되지 않는 기능이 있는 경우 원인 확인과 변경
    * 필요시 소스코드 수정
* MS Window 환경
  * 개발도구: MS Visual Studio, Dev C++
  * MS Visual Studio 사용법
    * 프로젝트 생성 - 소스 파일 추가 - 소스 코드 작성 - 빌드 - 실행하기
* Linux / Unix 환경
  * 텍스트 환경 (일반적)
    * 편집기 (주로 `vi`)를 이용하여 소스 파일 생성
    * 컴파일 도구를 이용하여 실행 파일 직접 실행
    * Unix 컴파일러: 각 벤더에서 제공하는 상용 C 컴파일러
    * 최근 모든 Linux와 대부분의 Unix에서 오픈 소스 도구인 gcc 컴파일러 사용
    * 그래픽편집기 gedit과 C 컴파일러 gcc 사용
  * 데스크탑 환경
    * 그래픽 편집기를 이용하여 소스코드를 좀 더 쉽게 작성할 수 있음
    * eclipse, kdevelop 도구 이용
      * eclipse: JAVA 프로그래밍 도구이나 C/C++ 개발도구로 활용 가능
        * 초기 설정 필요: 창(W)에서 선택

### 2. 나의 첫 번째 C 프로그램

### 3. 기본적인 데이터 표현 방법

#### 1) 변수와 자료형

* C의 기본 자료형

  * `char`
    * 문자 하나
    * ASCII 코드 이용
    * 1byte = 8bit
  * `int`
    * 정수값
    * DOS, Window3.1 등 16비트 운영체제에서는 16비트(2바이트)
    * 현재 32/64비트 운영체제에서는 4바이트 메모리공간 사용
  * `float/double`
    * 소수점이 포함된 실수
    * 4바이트 / 8바이트
  * `void`
    * "값이 없음"
    * 표현하기 위한 데이터가 없는 경우
    * void 함수의 경우 리턴값이 없음

* 변수의 선언 및 사용

  * 변수를 사용하는 이유

    * 프로그램에서의 데이터 처리를 위해
    * 변수: 데이터를 저장하는 메모리 공간의 이름

  * C언어에서는 변수 사용 전 변수를 선언하여 메모리공간을 확보해야 함.

  * 변수 선언 형식

    ```text
    자료형 변수명;
    자료형 변수명1, 변수명2, ... , 변수명N;
    ```

    * 변수명은 영어 대/소문자, 숫자, _ 로 구성
    * 첫 글자로 숫자가 올 수 없음

  * 변수에 값을 대입하는 방법: 대입기호 `=` 사용

    * 변수명 = 값;
    * 변수 선언 시 할당 받은 메모리 공간에 값 저장
    * 이제 변수명은 메모리에 저장된 값을 의미

  * 변수 초기화

    * 변수 선언 후 초기값 대입

      ```text
      char letter;
      letter='A';
      ```

    * 변수 선언과 동시에 초기화

      ```text
      char letter='A';
      ```

* 자료형과 데이터의 크기

  * 변수를 미리 선언하는 이유
    * 데이터를 저장하기 위한 메모리 공간 확보
    * `char` : 1byte, `int`: 4byte, `float`: 4byte, `double`: 8byte
  * `sizeof` 함수
    * 자료형이나 변수의 메모리 할당 크기를 바이트 단위로 반환
    * int sizeof(자료형); 또는 int sizeof(변수); 로 사용
    * 배열, 구조체에서도 많이 사용

#### 2) 상수와 const

* 상수의 종류

  * 변수: 값이 변경될 수 있는 수
  * 상수: 언제 어디서나 값이 변하지 않는 수
  * C에서 제공하는 상수
    * 리터럴 상수: 직접 값으로 표현하는 상수
    * 심볼릭 상수: const 지시어로 선언하는 변수

* 리터럴 상수

  - 정수형 상수 - 컴파일 시 int 형으로 간주
  - 실수형 상수 - 컴파일 시 double 형으로 간주
    - 상수의 자료형을 정확히 명시하고 싶을 경우 접미사 사용
      - 정수형상수L : long
      - 실수형상수F : float
      - 실수형상수L : long double
  - 문자 상수 - ''
    - 'A' : 1byte 메모리에 영문자 A를 상수로 표현. `문자` 의미.
  - 문자열 상수 - ""
    - "A" : A 문자와 문자열 끝을 알리는 '\0' 문자를 결합. 2byte. A와 \0 `문자열의 시작 주소` 의미.

* 심볼릭 상수

  - 상수를 기호화하여 사용하는 상수로 변수 선언 시 const 키워드와 함께 선언.

  - 형식

    ```text
    const 자료형 변수명 = 초기값;
    ```

  - 변수 선언 시 초기화된 값을 중간에 변경 불가능

  - 변수명을 통해 메모리 할당을 받았지만, 상수처럼 사용

  - 변수 값을 변경하지 않아야 하는 경우 많이 사용

#### 3) 연산자의 종류

* C에서 제공하는 연산자 (우선순위 기준 정렬)

  | 종류                       | 연산자                                                  | 결합순서         | 우선순위         |
  | -------------------------- | ------------------------------------------------------- | ---------------- | ---------------- |
  | 괄호<br />배열<br />구조체 | `()`<br />`[]`<br />`-> .(dot)`                         | 좌에서 우로 연산 | 1                |
  | 단항                       | `-` `!` `~` `++` `--` `(type)` `&` `*` `sizeof()`       | 우에서 좌로 연산 | 2                |
  | 산술                       | `*` `/` `%`<br />`+` `-`                                | 좌에서 우로 연산 | 3<br />4         |
  | 비트 시프트                | `<<` `>>`                                               | 좌에서 우로 연산 | 5                |
  | 관계                       | `<` `<=` `>=` `>`<br />`==` `!=`                        | 좌에서 우로 연산 | 6<br />7         |
  | 비트                       | `&`<br />`^`<br />`|`                                   | 좌에서 우로 연산 | 8<br />9<br />10 |
  | 논리                       | `&&`<br />`||`                                          | 좌에서 우로 연산 | 11<br />12       |
  | 조건(3항)                  | `?:`                                                    | 우에서 좌로 연산 | 13               |
  | 대입                       | `=` `+=` `-=` `*=` `/=` `%=` `>>=` `<<=` `&=` `^=` `!=` | 우에서 좌로 연산 | 14               |
  | 콤마                       | `,`                                                     | 좌에서 우로 연산 | 15               |

* 연산자의 종류 구분

  * 산술 연산자: 사칙연산자 + modular(나머지) 연산자
    * C언어에서는 동일한 자료형의 피연산자를 연산하면 동일한 자료형의 결과를 얻는다.
    * 사칙연산자는 모든 기본 자료형과 함께 사용 가능하지만, modular 연산자는 정수형에서만 사용 가능하다.
  * 증감 연산자: `++` `--`
    * 전위형, 후위형 : 단독으로 사용할 때에는 차이가 없으나 다른 연산자와 혼용할 경우 차이가 있음
    * 전위형 증감연산자 포함: 변수 값 증감 연산 후 연산식에 적용
    * 후위형 증감연산자 포함: 변수 값을 연산식에 적용 후 증감 연산
    * 증감 연산자 사용 시 주의사항
      * 한 연산식에서 동일한 변수에 여러 번의 증감연산자를 사용하지 않는다.
      * 컴파일러가 해석하는 방법에 따라 서로 다른 결과를 초래한다.
  * 관계 연산자
    * 두 수나 식의 `대소 관계` 및 동등 관계 판단
    * 연산 결과: 참(1)이나 거짓(0)
    * 주로 참 거짓을 판단하는 조건식에 사용
    * 정수값 출력 가능

  * 논리 연산자

    * `참 또는 거짓과 같은 논리값`을 이용
    * 연산 결과: 참(1)이나 거짓(0)
    * 주어진 여러 개의 식을 판단하고자 할 때 필요
    * 정수값 출력 가능

  * 비트 연산자

    * 비트를 잘 조작하면 일반적인 산술 연산보다 더 빠른 속도로 연산 가능
    * 메모리의 효율적인 사용을 위해 비트 단위로 데이터를 처리하는 경우 사용
    * 장치 제어 프로그램 작성 시 비트 단위의 제어가 필요한 경우 사용
    * 시스템 소프트웨어나 운영체제의 커널 프로그램
    * 여러 속성이 하나의 자료형에 혼합되어있을 때  원하는 속성값만을 추출, 변경하는 경우 사용 가능

    | 연산자 | 기능                                                         |
    | ------ | ------------------------------------------------------------ |
    | `&`    | 비트끼리의 AND<br />: 특정 비트를 강제적으로 0으로 만들거나, 특정 비트의 값을 확인하는 용도로 사용 |
    | `|`    | 비트끼리의 OR<br />: 특정 비트를 무조건 세팅하는 용도로 사용 |
    | `~`    | 1의 보수<br />: 특정 비트를 해제하는 용도로 사용             |
    | `^`    | 비트끼리의 XOR<br />: 반전시키고자 하는 부분만 1과 연산하면 원하는 부분만 반전된다. 반복적인 점멸 처리나 캐럿의 깜박임, 텍스트 블록을 보여주는 용도로 사용한다. `^` 연산을 반복하면 원형은 손상하지 않고 복구 가능하다. |
    | `>> n` | 오른쪽으로 n 비트 이동<br />: 나누기 2 효과. 빠른 산술 연산 시 이용. |
    | `<< n` | 왼쪽으로 n 비트 이동<br />: 곱하기 2 효과. 빠른 산술 연산 시 이용. |

    * 좌변과 우변의 데이터는 정수형 또는 문자형
    * 좌변과 우변의 데이터 간 대응되는 비트끼리 연산한 결과 산출

  * cast 연산자

    * C언어에서는 연산 시 자료형이 다를 때 자동적으로 형 변환이 이루어짐
    * 명시적으로 형 변환을 하고자 하는 경우, cast 연산자(형 변환자) 이용
    * 이미 선언된 변수의 자료형 자체가 변경되는 것이 아님
    * 연산이 진행되는 동안만 잠시 형 변환 후 원래의 자료형 유지
    * 형식: `(자료형) 변수명`

  * 기타 연산자

    * 대입 연산자: `=`
      * 오른쪽의 값을 왼쪽의 변수에 집어넣음
      * `왼쪽`: 저장 가능한 변수, 배열의 원소, 구조체 멤버 등
      * `오른쪽`: 어떤 표현이든 가능
      * 축약형 대입 연산자 - 연산식을 좀 더 간결하게 처리
    * 조건 연산자: `?:`
      * 조건에 따라 선택적인 수행
      * 결과는 변수에 저장 또는 다른 수식에 포함 가능
      * 형식: `조건식 ? 식1 : 식2`
      * 조건식이 참인 경우 식1 수행, 거짓인 경우 식2 수행
    * 컴마 연산자: `,`
      * 각 연산자를 나열하고 왼쪽에서 오른쪽으로 실행
      * 대입 연산자보다 우선 순위가 낮으므로 연산자의 혼합 사용 시 괄호 필요
      * 반복문에서 두 개의 반복제어 변수들을 초기화하기 위해 사용 가능

#### 4) 사용자 정의 자료형

* `typedef` 문

  * 사용자가 새로운 자료형의 이름을 선언할 수 있도록 해주는 명령문
  * 기존의 자료형에 새로운 이름을 부여하는 의미
  * 형식: `typedef 기존자료형명 새로운자료형명;`

* `enum` (나열형) 자료형

  * 하나 이상의 정수형 상수를 원소로 갖는 집합

  * 형식: `enum tag_name {enum 목록} 변수명;`

  * 주의사항

    * enum 목록에 나열된 것은 정수형 상수
    * enum 자료형으로 선언한 변수는 정수형 변수와 동일하게 처리

  * 예시

    ```c
    enum weekday {sun=10, mon, tue, wed, thu, fri, sat} day;
    ```

    * 순차적인 값을 가지므로 sun=10, mon=11, sat=16

  * enum 자료형을 만들어 사용하는 이유

    * 소스코드 작성 시 가독력이 좋은 프로그램을 작성하기 위해 숫자 대신 심볼릭한 문자 사용

### 4. 선택의 흐름이 필요한 경우 - 선택문의 사용

### 5. 반복적인 흐름이 필요한 경우 - 반복문의 사용

#### 1) while 문

* while 문의 형식

  * while 문은 조건이 만족되는 동안에는 계속 반복해야 하는 구조에 적합한 반복문

  * 반복 횟수보다는 조건이 반복 여부를 결정

  * 조건식(c언어에서 사용 가능한 모든 표현식)을 먼저 수행하여 반복 여부를 결정

  * 조건식이 참이면 명령문 실행 후 다시 조건문 확인

  * 형식

    ```c
    while (조건식) // 명령문이 하나인 경우
        명령문;
    while (조건식) { // 명령문이 여러개인 경우. {}: 코드블록
        명령문1;
        명령문2;
        ...
    }
    ```

  * 반복문의 기본 형식 이외의 패턴

    * 무한루프
      * 조건식의 수행 결과가 항상 참인 경우
      * 반복문 내의 명령문 수행 중 강제로 반복문을 벗어나도록 제어하지 않으면 프로그램은 중단되지 않고 계속 while 반복문 내의 명령문을 수행
    * 중첩
      * 반복문 안에 또 다른 반복문을 포함하는 경우

* while 문의 사용

  * 예제1) 정수를 반복해서 입력 받는 프로그램

    ```c
    #include <stdio.h>
    int main()
    {
        int number, count=0;
        
        printf("input:");
        scanf("%d", &number);
        while(number!=-999) {
            count++;
            printf("input:");
            scanf("%d", &number);
        }
        printf("count = %d\n", count);
        return 0;
    }
    ```

#### 2) do-while 문

* do-while 문의 형식

  * while 문과 유사한 반복문

  * 반복여부를 결정짓는 조건식이 반복문 뒤쪽에 있어서 반복 수행할 명령문을 먼저 수행한 후 반복을 계속할지 여부 결정

  * 최소한 한 번 이상 반복 명령문을 수행하는 구조라면 do-while 문 사용

  * 예) 메뉴 기반 프로그램

    * 처음 시작할 때 메뉴 출력 후 사용자의 선택을 기다린다.
    * 사용자의 선택에 따라 반복 여부가 결정되므로 사전에 사용자의 선택을 입력 받아야 한다.

  * 형식 - `while(조건식)` 뒤에 반드시 세미콜론(`;`) 필요

    ```c
    do
        명령문;
    while (조건식);
    
    do {
        명령문1;
        명령문2;
        ...
    } while (조건식);
    ```

  * 예제2) 정상적인 시험 점수가 입력되면 반복문을 빠져 나오는 프로그램

    ```c
    #include <stdio.h>
    
    int main()
    {
        int score;
        do {
            printf("input a score : ");
            scanf("%d", &score);
        } while(score<0 || score >100);
        printf("Correct, valid score!\n");
        return 0;
    }
    ```

#### 3) for 문

> while문과 do-while문은 반복 조건에 따라 반복 여부가 결정되는 구조에 적합. 반복 횟수가 일정한 반복문이 필요한 경우 for문을 이용하는 것이 효과적.

* for 문 : 일정한 횟수의 연속적인 동작을 수행할 때 적합

* for 문의 형식

  * 구조

    * 초기값 설정: 반복 횟수를 계산하는 반복 변수를 두어 for문이 시작될 때 이 변수에 초기값 설정.
    * 조건식: 반복 여부 결정
    * 증감식: 반복 변수를 증감 또는 재평가

  * 형식

    ```c
    for(초기값설정; 조건식; 증감식) 
        // 초기값설정은 for문이 시작될 때 한 번만 실행
        명령문;
    
    for(초기값설정; 조건식; 증감식) {
        명령문1;
        명령문2;
        ...
    }
    ```

  * 초기값설정 - 조건식 - 명령문 - 증감식 - 조건식 - 명령문 -... - 반복종료

  *  초기값설정, 조건식, 증감식 모두 생략 가능. `;` 2개는 반드시 존재해야 함.

  * for 문의 기본 형식 이외의 패턴

    * 무한 루프

      ```c
      for(;;)
          명령문;
      ```

      * 명령문 부분에서 특별히 제어하지 않는 한 프로그램은 이 반복문에서 빠져나올 수 없음

    * 중첩

* for 문의 사용

  * 예제3) 1에서 1000까지의 합을 구하는 프로그램

    ```c
    #include <stdio.h>
    
    int main()
    {
        int number, sum=0; // sum 초기화
        
        for(number=1;number<=1000;number++)
            sum+=number;
        
       	printf("sum = %d\n", sum);
        return 0;
    }
    ```

  * 예제4) 10개의 정수를 입력받아 제일 큰 수를 찾아 출력하는 프로그램(음수는 입력되지 않음)

    ```c
    # include <stdio.h>
    
    int main()
    {
        int i, num;
        int max=0;
        for(i=1;i<=10;i++){
            scanf("%d", &num):
            if(num>max)
                max=num;
        }
        printf("max = %d\n", max);
        return 0;
    }
    ```

    

