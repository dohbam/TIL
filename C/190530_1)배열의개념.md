### 7. 배열이 왜 필요할까요?

#### 1) 배열의 개념

* 배열과 메모리

  * 프로그램의 데이터 처리는 변수를 통해 진행
  * 변수는 데이터를 하나만 저장
  * 다량의 데이터를 사람들이 원하는 정보로 신속하고 정확하게 처리
  * 여러 데이터를 한꺼번에 다룰 수 있는 구조 필요 - 배열
  * `배열` : 자료형이 동일한 데이터들의 연속적인 모임
  * 배열에서는 데이터의 순차적인 접근이 가능

* 배열의 선언

  * 형식

    ```C
    자료형 배열명[크기];
    // 크기 : 배열 안에 최대 모아놓을 수 있는 데이터 수
    ```

    * 배열 선언도 메모리 할당을 의미함
    * 할당 받은 메모리의 크기 = (자료형의 크기) * (배열의 크기)

    | 배열 선언         | 배열명의 의미                    | (자료형의 크기) * (배열의 크기) |
    | ----------------- | -------------------------------- | ------------------------------- |
    | char letter[80];  | 최대 80개의 문자 보관 가능       | 1* 80 = 80 bytes                |
    | int number[10];   | 정수 10개 보관 가능              | 4 * 10 = 40 bytes               |
    | float weight[20]; | 실수 20개 보관 가능              | 4 * 20 = 80 bytes               |
    | double area[30];  | 좀 더 세밀한 실수 30개 보관 가능 | 8 * 30 = 240bytes               |

* 배열의 표현

  * 배열이 선언되면 연속적으로 할당된 메모리에 여러 데이터의 저장 가능
  * 각각의 데이터에 따로 접근할 수 있고 배열 전체로 한꺼번에 접근도 가능
  * 각각의 데이터 = `배열의 원소(elementary)`
  * 표현하는 형식은 배열명[첨자]
    * `첨자` : 배열에 있어 원소의 위치, 0부터 출발

#### 2) 1차원 배열

* `1차원 배열` : 동일한 자료형을 가진 데이터의 모임

* `2차원 배열` : 동일한 1차원 배열들의 모임 

* `다차원 배열` : 2차원 이상의 배열

  | C언어가 제공하는 자료형 | 데이터 배열 |
  | ----------------------- | ----------- |
  | char 자료형             | 문자 배열   |
  | int 자료형              | 정수 배열   |
  | float 자료형            | 실수 배열   |
  | double 자료형           | 실수 배열   |
  | 포인터 자료형           | 포인터 배열 |
  | 구조체 자료형           | 구조체 배열 |

* `정수 배열` : 정수형의 데이터들을 모아놓은 정수 배열

  * 배열의 원소 하나하나는 int 자료형의 변수와 동일한 의미
  
    | 동작 | number변수           | num[0]                |
    | ---- | -------------------- | --------------------- |
    | 대입 | number = 10;         | num[0] = 10           |
    | 입력 | scanf("%d", &number) | scanf("%d", &num[0]); |
    | 출력 | printf("%d", number) | printf("%d", num[0]); |
  
  * 배열의 이름과 시작 주소
  
    * 배열의 이름은 배열에 할당된 메모리의 시작 주소를 의미하므로 배열 명에는 대입 연산자를 사용할 수 없음
    * 예) char book[30];을 선언 시 메모리 1000번지로부터 30bytes를 할당받았다면?
      * book이라는 배열이 이름은 1000번지를 의미함
      * book = 10;은 1000=10; 과 같은 의미기 때문에 사용할 수 없음
      * 대입연산지는 왼쪽에 변수명이 와야하는데 상수이므로 대입이 성립할 수 없음
  
  * 예제1) 정수 10개를 저장할 수 있는 num배열 선언, 사용자로부터 입력 받고 출력하는 프로그램 작성
  
    ```C
    #include <stdio.h>
    int main()
    {
    	int num[10];
    	int i;
        
    	printf("10개의 정수를 입력하세요\n");
    	for (i = 0; i < 10; i++)
    		scanf("%d", &num[i]);
    	for (i = 0; i < 10; i++)
    		printf("%d. %d\n", i + 1, num[i]);
    	return 0;
    }
    ```
  
  * 예제2) 10개의 정수를 입력받고, 가장 큰 수를 찾는 프로그램 작성
  
    ```C
    #include <stdio.h>
    int main()
    {
    	int num[10];
    	int i, max;
    
    	printf("10개의 정수를 입력하세요\n");
    	for (i = 0; i < 10; i++)
    		scanf("%d", &num[i]);
    	max = num[0];
    
    	for (i = 0; i < 10; i++)
    		if (num[i] > max)
    			max = num[i];
    	printf("최대값은 %d입니다\n", max);
    	return 0;
    }
    ```
  
* `실수 배열` : 실수형의 데이터들을 모아놓은 실수 배열

  * 예제3) 10명의 몸무게(소수점 이하 둘째 자리까지)를 입력 받아 평균을 구하는 프로그램 작성

    ```C
    #include <stdio.h>
    int main()
    {
    	float weight[10];
    	float total = 0, average;
    	int i;
    
    	printf("10명의 몸무게를 입력하세오.\n");
    	for (i = 0; i < 10; i++) {
    		scanf("%f", &weight[i]);
    		total = total + weight[i];
    	}
    	average = total / 10;
    	printf("10명의 평균 몸무게는 %.2f입니다\n", average);
    	return 0;
    }
    ```

* 배열의 초기화와 매크로 사용

  * 배열도 선언과 동시에 초기화 가능

  * 형식

    ```
    자료형 배열명[크기] = {값1, 값2, ..., 값N};
    ```

    * 선언과 동시에 초기화 하는 경우에는 배열의 크기 생략 가능
    * 생략하면 초기화한 개수로 배열의 크기가 정해짐
    * 예) int num[] = {1, 2, 3, 4, 5, 6, 7};
    * num 배열의 크기 : 7
    * 크기가 정해져 있지 않아 **언사이즈드(unsized) 배열**이라고 부름
    * 초기화된 개수를 초과해 사용할 수는 없음

  * 예제4) 실수 배열을 선언하고 동시에 초기화하여 출력하는 프로그램 작성

    * 배열의 초기화는 중괄호({})이용

    * 언사이즈드 배열로 선언하면 초기화한 데이터의 개수만큼 배열의 크기 결정

    * sizeof함수를 이용하면 배열의 크기 알 수 있음

      ```C
      #include <stdio.h>
      int main()
      {
      	float weight[] = { 56.7, 78.9, 55.4, 58.9 };
      	int i, count;
      
      	count = sizeof(weight) / sizeof(weight[0]);
      	printf("count: %d\n", count);
      	for (i = 0; i < count; i++) {
      		printf("%d. %.2f\n", i, weight[i]);
      	}
      	return 0;
      }
      ```

  * 매크로 사용하기

  * 배열은 선언 시 정해진 크기만큼 반복작인 작업을 많이 수행

  * 만약 배열의 크기를 변경해야 한다면?

    * 선언 부분, for문의 조건식도 다 수정해야 하므로 이때 매크로를 이용하면 프로그램 수정이 용이함

    * `매크로` : #define 매크로명 값

    * 값 뒤에는 세미콜론 붙이지 않음

      ```C
      // 반복문 표현
      int num[10];
      for (i=0;i<10;i++)
          ...
      for (i=0;i<10;i++)
          ...
          
      // 매크로 적용
      #define MAX 10
      // 20으로 변경 시 배열을 크기를 20으로 늘려야 하는 경우 다른 부분은 수정하지 않아도 됨
      int num[MAX];
      for (i=0;i<MAX;i++)
          ...
      for (i=0;i<MAX;i++)
          ...
      ```

  * '#'으로 시작되는 명령문

    * #include, #define, #if ~ #endif 등과 같이 '#' 문자로 시작되는 명령문을 전처리 구문이라고 함
    
    * 컴파일러가 컴파일하기에 앞서 소스코드를 정리하는데 이용되는 명령문들
    
    * 명령문들은 마지막에 세미콜론을 붙이지 않음
    
      | 전처리 구문 | 명령어 실행 결과                                             |
      | ----------- | ------------------------------------------------------------ |
      | #include    | 다음에 오는 헤더 파일을 소스 코드에 포함                     |
      | #define     | 소스 코드 중 다음에 지정된 매크로명으로 되어있는 부분을 모두 매크로명 뒤에 정의된 값으로 수정 |
      | #if~#endif  | 이 명령문 사이에 오는 명령문들을 조건에 따라 소스코드에 포함(1) 또는 제외(0) |
  
* 문자 배열과 문자열처리 함수

  * `문자 배열` : 여러 문자들을 모아놓은 문자 배열

  * C언어에서는 따로 문자열이라는 자료형을 제공하지 않기 때문에 문자 배열을 이용하여 문자열 처리

  * `문자열` : 마지막에 문자열의 끝을 알리는 종료 문자로 널(null)문자를 가지는 일련의 문자들

  * `널(null)문자` : `\0` 또는 `0`로 표현, 배열은 `긴 문자열의 길이 +1` 의 크기로 선언

  * 문자를 따로 다루는 경우

    | letter[0] | letter[1] | letter[2] | letter[3] | letter[4] | letter[5] |      | letter[10] |
    | --------- | --------- | --------- | --------- | --------- | --------- | ---- | ---------- |
    | 'H'       | 'A'       | 'P'       | 'P'       | 'Y'       | '\0'      | ...  | '\0'       |

    * letter[5]에 널문자 저장, 이후 어떤 문자도 무시
    * 일련의 문자열은 이중따옴표(" ")로 표시, 문자 하나는 단일따옴표(' ')로 표현
    * 이중따옴표(" ")로 표시하면 항상 문자열의 끝에는 '\0' 널문자 포함
    * `이중따옴표` : 문자열의 시작 주소
    * `배열의 이름` : 할당된 메모리의 시작 주소
    * 이중따옴표와 배열의 이름은 같은 의미로 사용

  * 문자를 한꺼번에 다루는 경우

    ```C
    char string[80] = "Hello";	// 배열의 선언과 초기화 또는 
    							// char string[80] = ['H', 'e', 'l', 'l', 'o', '\0'];
    scanf("%s", string);		// 형식 지정자 %s 이용
    printf("%s", string);
    ```

    * scanf 함수에서 변수명 앞에는 항상 주소연산자인 &를 붙임
    * 배열의 이름이 주소를 의미하는 경우에는 &를 붙이지 않음

  * 문자배열 초기화와 대입

    * 선언과 초기화

      ```C
      char string[] = "C Language";
      // 선언과 동시에 문자열로 초기화 가능
      string = "C Language";
      // 대입 연산은 불가능
      // 이름 자체가 시작주소(상수)이기 때문에 대입이 불가능
      ```

  * 예제5) 문자열 입출력 프로그램 작성

    ```C
    #include <stdio.h>
    int main()
    {
    	char name[20];
    
    	printf("당신의 이름?");
    	scanf("%s", name);
    	printf("당신의 이름은 %s 이군요\n", name);
    	return 0;
    }
    ```

  * `문자열처리 함수` : C언어에서 제공되는 문자열 처리 함수

  * 문자열을 비교하거나 문자 개수를 알아야 하는 경우 라이브러리함수 형식으로 제공되므로 바로 사용 가능

  * `char *strcpy(char *dest, const char *src);`

    * src의 문자열을 dest의 배열로 복사하는 문자열 복사 함수

    * `src` : 문자 배열의 이름, 이중따옴표의 문자열 지정 가능

    * dest가 가리키는 배열의 크기는 src가 가리키는 문자열의 길이보다 커야함

    * dest가 가리키는 배열이 작거나 같으면 널 문자를 복사할 수 없으므로 문자열로 다룰 수 없음 

    * 컴파일러에서는 점검할 수 없으므로 프로그램 작성 시 유의

    * 예

      ```c
      char to[80], from[80];
      strcpy(from, "Hello, C");
      strcpy(to, from)
      ```

      * to 와 from 배열에 모두 "Hello, C"라는 문자열 복사

  * `char *strcat(char* dest, const char* src);`

    * dest가 가리키는 문자열 뒤에 src가 가리키는 문자열을 덧붙이는 함수

    * 예

      ```C
      char to[80]="Hello", from[80]="World";
      strcat(to, from);
      ```

      * to 배열에는 "Hello, World"문자열 저장
      * dest가 가리키는 문자 배열의 남은 공간에 src가 가리키는 문자열의 추가 가능 여부 확인

    * 문자열의 길이 확인

      ```C
      if (strlen(to) + strlen(from) < sizeof(to)/sizeof(to[0]))
          strcat(to, from);
      ```

      * strcat함수를 호출하기 전 추가해서 실행
      * `strlen` 함수 : 문자열의 길이
      * `sizeof` 함수 : 배열에 할당된 메모리 크기
      * strlen(to) 함수와 strlen(from) 함수의 수행 결과 : 6
      * sizeof(to)/sizeof(to[0]) 의 수행 결과 : 80

  * `int strcmp(const char *s1, const char *s2);`

    * s1과 s2가 가리키는 문자열을 비교하는 함수

    * 문자열의 대소관계는 영한사전에서 단어의 위치가 뒤쪽에 있는 것을 크다고 판단

      | 반환 값 | 의미                              | 사용 예                                                   |
      | ------- | --------------------------------- | --------------------------------------------------------- |
      | 0       | 두 문자열이 동일한 경우           | char s1[]="apple",  s2[]="apple";<br />n=strcmp(s1, s2);  |
      | > 0     | s1이 가리키는 문자열이 더 큰 경우 | char s1[]="banana",  s2[]="apple";<br />n=strcmp(s1, s2); |
      | < 0     | s2가 가리키는 문장열이 더 큰 경우 | char s1[]="apple",  s2[]="grape";<br />n=strcmp(s1, s2);  |

    * 예

      ```C
      char str1[]='student', str2[]='teacher';
      n = strcmp(str1, str2);
      ```

      * str2 배열의 내용이 더 크므로 n변수에는 음수가 들어감

  * `size_t strlen(const char *s);`

    * 문자열의 길이를 바이트 단위로 계산해서 반환하는 함수

    * 널문자의 개수는 미포함

    * 예

      ```C
      char name[20] = "kildong";
      int n = strlen(name);
      ```

      * "kildong"의 문자 개수인 7이 n에 대입

  * 문자열을 다루는 함수는 반드시 `#include <string.h>`헤더파일을 포함

  * `strcpy`, `strcat`, `strcmp`은 길이를 제한하지 않고 처리하는 함수이기 때문에 잘못 처리하면 프로그램 다운 및 불필요한 문자들이 출력

  * 안전한 문자열 처리를 위해서 아래와 같이 사용

    * `char *strcpy(char *dest, const char *src, size_t n);` : 문자열 복사 함수
    * `char *strcat(char* dest, const char* src, size_t n);` : 문자열 추가 함수
    * `int strcmp(const char *s1, const char *s2, size_t n);` : 문자열 비교 함수
    * 세번째 매개변수에 문자의 개수를 지정하며 일정한 개수만 복사, 추가, 비교

  * 예제6) 문자열을 입력받아 big_array 배열에 추가하는 프로그램 작성

    * big_array 배열의 크기는 500바이트이고, 입력 도중 "end" 문자열이 입력되면 입력을 끝내고 big_array 배열의 내용 출력

    ```C
    #include <stdio.h>
    #include <string.h>
    
    int main()
    {
    	char big_array[500] = "";
    	char string[80];
    	int max = sizeof(big_array) / sizeof(big_array[0]);
    	while (1) {
    		printf("문자열을 입력하세요:");
    		scanf("%s", string);
    		if (strcmp(string, "end") == 0)
    			break;
    		if ((strlen(big_array) + strlen(string) + strlen(",")) < max) {
    			strcat(big_array, string);
    			strcat(big_array, ",");
    		}
    	}
    	printf("big_array  : [%s] \n", big_array);
    	return 0;
    }
    ```

#### 3) 다차원 배열

* 2차원 배열과 3차원 배열

  * `2차원 배열` : 행의 요소 추가 외에 1차원 배열의 원리 적용

  * 자료형 배열명[행의 크기] [열의크기];

  * 원소란 배열에 모여있는 데이터를 하나하나 가리키는 용어

  * 원소 하나하나를 다룰 때는 같은 자료형의 변수와 동일하게 처리

  * 첨자는 원소의 위치를 나타내며 0부터 시작

  * 2차원의 정수 및 실수 배열

    * 배열 선언

      ```C
      int twod[2][3]; // 배열 선언
      ```

      |      | 0 열        | 1 열        | 2 열        |
      | ---- | ----------- | ----------- | ----------- |
      | 0 행 | twod[0] [0] | twod[0] [1] | twod[0] [2] |
      | 1 행 | twod[1] [0] | twod[1] [1] | twod[1] [2] |

      * 앞에 있는 첨자는 행의 위치, 뒤에 있는 첨자는 열의 위치

    * 선언과 초기화

      ```C
      int twod[2] [3] = {1, 2, 3, 4, 5, 6}; 	// 배열 선언 및 초기화
      // 또는
      int twod[] [3] = {1, 2, 3, 4, 5, 6};
      ```

      * 행의 크기가 생략되어도 초기화한 원소의 개수를 계산해서 행의 크기 결정
      * 열의 크기는 반드시 명시해야 함

  * 메모리 배치

    * 각 원소마다 4바이트씩 배치됨
    * 프로그램 작성 시 연속적인 접근이 가능하도록 구성해야 효율적인 메모리 접근이 가능

  * twod 배열에 정수 입력

    ```C
    for (i=0;i<2;i++)
        for (j=0;j<3;j++)
            scanf("%d", &twod[i][j])
    ```

    * 행의 첨자를 i 변수로, 열의 첨자를 j 변수로 변경시키면서 입력 받음 

  * 예제7) 2차원의 정수 배열을 선언하고, 입출력하는 프로그램 작성

    ```C
    #include <stdio.h>
    
    int main()
    {
    	int num[5][3];
    	int i, j;
    
    	for (i = 0; i < 5; i++) {
    		printf("3개의 수를 입력하세요");
    		for (j = 0; j < 3; j++)
    			scanf("%d", &num[i][j]);
    	}
    
    	for (i = 0; i < 5; i++) {
    		for (j = 0; j < 3; j++)
    			printf("%d \t", num[i][j]);
    		printf("\n");
    	}
    	return 0;
    }
    ```

  * 2차원의 문자 배열

    * 문자 배열의 예

      ```C
      char colors[10][20];
      ```

    * 문자 배열 colors의 초기화

      ```C
      char colors[10][20] = ["RED", "BLUE", "GREEN", ..., "PINK"]
      ```
  
      |           | ㅇ   | 0 열 | 1열  | 2열  | 3열  |      |      | 19 열 |
      | --------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----- |
      | colors[0] | 0 행 | 'R'  | 'E'  | 'D'  | '\0' |      |      |       |
      | colors[1] | 1 행 | 'B'  | 'L'  | 'U'  | 'E'  | '\0' |      |       |
      | colors[2] | 2 행 | 'G'  | 'R'  | 'E'  | 'E'  | 'N'  | '\0' |       |
      |           | ...  |      |      |      |      |      |      |       |
      | colors[9] | 9 행 | 'P'  | 'I'  | 'N'  | 'K'  | '\0' |      |       |
      
      * 각 행마다 문자열 처리 함수의 사용 가능
      * colors 배열의 첫 번째 배열이 "RED"인지 확인하려면 `if (strcmp(colors[0], "RED")==0)`
    
  * 예제8) 문자열 배열을 선언 및 초기화하고 검색할 문자열을 입력하여 위치를 찾는 프로그램 작성
  
    ```C
    #include <stdio.h>
    #include <string.h>
    
    int main()
    {
    	char names[5][20] = {"kim", "lee", "park", "han", "jang"};
    	char sname[20];
    	int i;
    
    	for (i = 0; i < 5; i++)
    		printf("%d. %s\n", i + 1, names[i]);
    
    	printf("이름 입력:");
    	scanf("%s", sname);
    
    	for (i = 0; i < 5; i++)
    		if (strcmp(sname, names[i]) == 0)
    			printf("%s 는 %d 번째 원소입니다.", sname, i + 1);
    
    	return 0;
    }
    ```
  
  * `3차원 배열` : 1, 2차 배열의 원리와 동일하게 적용
  
  * 2차원 배열의 연속적인 모임
  
  * 형식
  
    ```C
    자료형 배열명[면의 수][행의 크기][열의 크기];
    ```
  
  * 원소의 표현 : 배열명, 면의 위치, 행의 위치, 열의 위치를 첨자로 표현
  
  * 3차원 배열이 필요한 경우 - 한 학년의 성적 처리
  
    * 조건 : 전체 9반, 한 반의 학생 수 30명, 시험 과목 4과목
  
    * 배열 선언
  
      ```C
      float first_score[9][30][4]
      ```
  
    * 시험 점수 입력
  
      ```C
      for (i=0; i<9; i++)
          for (j=0; j<30; j++)
              for (k=0; k<4; k++)
                  scanf("%f", &forst_score[i][j][k]);
      ```
  
      *  차수가 늘어날 때마다 반복문이 하나씩 더 중첩
      * 4차원, 5차원도 표현 가능

* 2차원 배열의 사용

  * 예제9) 2차원 배열을 이용하여 주소록 프로그램 작성

    * 주소록 : 이름, 주소, 전화번호
    * 최대 100개의 주소 저장 가능
    * 새로운 주소 정보 한 개 더 추가
    * 검색할 사람을 입력하면 주소와 전화번호 출력

    ```C
    #include <stdio.h>
    #include <string.h>
    
    int main()
    {
    	char names[100][20] = { "김희윤", "유지원", "조인정", "한단비", "황여진", "김예지" };
    	char address[100][30] = { "대전", "서울", "천안", "청주", "세종", "대전" };
    	char telno[100][20] = { "010-4342-9978", "010-2240-2248", "010-9270-3467",
    							"010-3700-6035", "010-5739-1222", "010-2760-7484" };
    
    	char sname[20];
    	int i, count = 6;	// 현재 등록된 원소 개수
    
    	printf("새로운 주소 정보를 추가하십시오\n");
    	printf("이름:");
    	scanf("%s", names[count]);
    	printf("주소:");
    	scanf("%s", address[count]);
    	printf("전화번호:");
    	scanf("%s", telno[count]);
    
    	count++;
    /* 
    조건부 컴파일 구문(디버깅을 위한 표현)
    새로운 정보 추가의 확인 여부는 0을 1로 변경
    테스트를 위해서만 필요하므로 테스트가 끝나면 다시 1을 9으로 변경하면 컴파일시 제외
    확인이 필요한 부분에 #if ~ #endif 문을 이용하여 원활한 디버깅 가능
    */
    #if 0
    	for (i = 0; i < count; i++)
    		printf("%s, %s, %s\n", names[i], address[i], telno[i]);
    #endif
    
    	while (1) {
    		printf("주소 확인을 원하는 사람의 이름을 입력하세요\n");
    		scanf("%s", sname);
    		if (!strcmp(sname, "end"))					// 검색 종료
    			break;
    		for (i = 0; i < count; i++) 		
    				if (!strcmp(sname, names[i])) {		// 찾은 경우
    				printf("%s 의 주소는 %s, 전화번호는 %s입니다.\n", sname, address[i], telno[i]);
    				break;
    			} 
    			if (i == count)							// 못 찾은 경우
    				printf("%s 는 존재하지 않습니다.\n", sname);
    	}
    	return 0;
    }
    ```

    














​    