### 6. 함수 왜 필요할까요?

#### 1) 함수란?

* 함수의 의미
  * 특정 동작을 수행하는 일정 코드 부분
  * 함수를 만들어 놓으면 동작이 필요로 하는 시점에 프로그램 어디서든지 함수를 호출해 실행 가능
  * 동작 중 일부에 수정 사항이 생기면 함수의 소스코드만 수정
  * 함수를 이용하지 않으면 특정 동작을 할 때 마다 직접 그 동작을 소스코드에 추가, 동작에 수정 사항이 생기면 해당 동작 부분 모두 변경
  * 함수를 이용하면 특정 동작을 할 때마다 함수를 호출, 동작에 수정 사항이 생기면 함수 안의 내용만 수정, 함수 실행 시 자동으로 수정된 동작을 수행
* 함수의 필요성
  * 프로그램 작성이 용이
    * 프로그램이 크고 복잡하면 여러 사람이 함께 개발하는 경우 프로그램을 기능별로 함수를 만들어 각자 맡은 부분의 프로그램을 만들 수 있음
    * 한 함수에 모든 기능을 모아두지 않고 모듈화를 해놓으면 필요 부분 찾기 쉬움, 필요할 때 원하는 동작만 수정 가능
    * 모듈화를 하지 않으면 문제가 생겼을 때 문제점 찾기 어려움, 추후 수정 불편
  * 소스코드를 재 사용할 수 있음
    * 함수를 잘 만들어 놓으면 다음 프로그램 작성 시, 또는 다른 사람이 프로그램 개발할 때에도 사용 가능, 개발 기간 단축
    * 함수 설계 시 범용적으로 만들면 활용성 더 높아짐
  * 분석하기 좋은 소스코드를 만들 수 있음
    * 함수 방식으로 모듈화시키면 한 번에 볼 수 있는 소스코드의 크기가 작아 쉽게 분석 가능, 오류의 원인 찾는 시간도 단축 
  * 함수를 나누는 기준은 정의 되어 있지 않음
  * 하나의 함수는 하나의 작업만 실행
  * 소스코드의 크기도 가급적 1페이지 이내

#### 2) 함수의 형식

* 함수의 선언과 정의

  * 라이브러리 함수

    * 이미 만들어져있는 함수
    *  필요 시 호출해서 실행만 하면 됨
    * 대표적인 예(printf 함수, scanf 함수)
    * C 언어에서 제공되는 라이브러리 함수는 굉장히 많음

  * 사용자 정의 함수

    * 개발자가 스스로 만들어 사용하는 함수
    * 함수의 구성 요소
      * 함수의 원형 선언(Declaration) 
      * 함수 정의(Definition)
      * 함수 호출(call), 실행

  * 함수 원형 선언 : 함수의 원형을 컴파일러에게 미리 알려줘 원형에 맞지 않는 잘못된 사용을 방지하기 위한 것

    * 컴파일 시 오류 메세지 전송
    * 모든 함수 정의 및 호출에 앞서 함수 선언부터 기술

  * 함수 선언 형식

    ```
    리턴_자료형 함수명([자료형 매개변수, ...]);
    ```

    * `리턴 자료형` : 함수의 수행 결과를 반환할 때 자료형 명시

      * int : 정수(return자료형을 생략한 경우에는 기본으로 int)
      * char : 문자
      * float, double : 실수
      * void : 반환 값이 없는 경우

    * `함수명` : 함수를 구분하는 요소

      * 프로그램 내에서는 유일하게 구성
      * 함수 명은 영어 대 소문자와 숫자 및 _로 구성

    * `자료형 매개변수` : 함수 호출 시 전달하는 인자가 있을 때 인자 하나하나에 일대일 대응하여 기술

      * 자료형은 반드시 기술, 매개변수 이름은 생략 가능
      * 인자 전달이 없는 함수면 매개변수 목록을 생략, 명시적으로 void자료형 기술

    * **함수 선언 시 마지막에 ;(세미콜론) 필요**

    * 함수 선언의 예

      | 함수 선언                       | 의미                                                         |
      | ------------------------------- | ------------------------------------------------------------ |
      | int sun(int);                   | sum 함수는 호출 시 정수 값을 1개 전달, 반환되는 값도 정수형  |
      | void input(void);               | input 함수는 호출 시 전달되는 인자가 없고 반환되는 값도 없음 |
      | float avg(int a, int b, int c); | avg 함수는 호출 시 정수값이 3개 전달되며 반환되는 값은 float형 |

  * 함수 정의 : 함수가 수행할 내용을 기술

    ```c
    리턴_자료형 함수_이름([자료형 매개변수, ...])
    // 함수 선언과의 차이점 : 소괄호 뒤에 ;이 없음
    {
    	명령문1;
    	명령문2;
    	...
    	명령문N;
    }
    // 중괄호 사이에 수행해야 할 명령문 기술
    ```

    * 반환값이 있는 함수에서는 return 명령을 이용하여 반환

      >  return [반환값];

      * 함수 선언 시 명시한 리턴 자료형과 일치하는 값
      * 리턴 자료형이 void로 명시된 함수라면 반환값 생략하고 return문만 이용 가능

* 함수의 실행

  * 함수의 호출 : 함수를 실행하는 것

    * 함수 호출 형식

      ```
      [변수=] 함수명([인자, ...])
      ```

    * 함수 선언에 맞춰 인자가 필요한 함수 : 소괄호 () 사이에 인자를 순서대로 기술

    * 반환 값이 있는 함수 : 리턴 자료형에 맞춰 변수를 선언하고 그 결과를 변수에 대입 가능

    * 함수 호출 시 함수 선언과 다르게 호출한 부분이 있으면 컴파일 과정에서 잘못 사용한 부분을 오류로 처리

#### 3) 함수의 매개변수

* 함수 호출 시 인자 전달
  
  * 인자 전달 : 함수 호출 시 실제로 전달되는 인자들이 함수의 매개변수로 대입되는 것
  
  * 예)  값에 의한 호출 방식
  
    ```C
    int n1=100, n2=200;
    add(n1, n2)
    ```
  
    * add 함수 호추 시 n1을 첫 번째 매개변수로, n2를 두 번째 매개변수로 전달
    * add 함수에서는 각각 정수형 매개변수에 전달받아 처리하도록 해야 함
  
  * 인자를 전달하는 방식
  
    * 값에 의한 호출(Call by Value)
    * 참조에 의한 호출(Call by Reference)
  
* 인자와 매개변수

  * **값에 의한 호출(Call by Value)** : 함수 호출 시 인자의 값이 함수의 매개변수로 대입

  * 형식

    ```
    함수 호출 : add(10, 20);
    함수 정의 : void add(int x, int y)
    ```

    *  인자 1인 10은 매개변수 1 인 x로, 인자 2인 20은 매개변수 2인 y로 각각 전달
    * 변수 선언과 같이 동작
    * `변수 선언` 
      메모리의 할당
      매개변수를 위한 할당된 메모리로 인자 값들이 저장
      메개변수를 변경하는 것은 인자나 호출한 함수 쪽으로 영향을 주지 않음

  * 예제 2) 값에 의한 호출 프로그램

    ```C
    #include <stdio.h>
    // 함수 선언
    void call_by_value(int number);
    int main()
    {
        int number=10;
        // 함수 호출
        call_by_value(number);
        printf("number = %d in main\n", number);
        return 0;
    }
    // 함수 정의
    void call_by_value(int number)
    {
        printf("BEFORE : number = %d in call_by_value\n",number);
        number=20;
        printf("AFTER : number = %d in call_by_value\n\n",number);
    }
    ```

    * call_by_value 함수 호출 시 main 함수에서 선언한 number 변수에 저장되어 있는 10이 call_by_value 함수의 매개변수 number에 전달
    * main의 number과 call_by_value의 number은 이름은 동일하지만 서로 다른 변수(메모리 할당이 서로 다른 곳에서 이루어지기 때문)

  * **참조에 의한 호출(Call by Reference)** : 함수 호출 시 값이 아니라 메모리의 주소를 전달

  * 형식

    ```
    함수 호출 : add(&n1, &n2);
    함수 정의 : void add(int* x, int* y)
    {
    	...
    }
    ```

    * add함수를 호출 할 때 인자1과 인자 2 앞에 주소 연산자 표시인 &가 있음
    * scanf에서의 &과 같은 의미
    * 함수 정의의 매개변수 부분을 보면 int*로 되어있음
      * 포인터(주소) 자료형 : 메모리의 주소 저장 가능
    * 매개변수 x에는 n1변수의 주소, 매개변수 y에는 n2변수의 주소가 전달

  * 예제 3) 참조에 의한 호출 방식

    ```C
    #include <stdio.h>
    // 함수 선언
    void call_by_value(int number);
    int main()
    {
    	int number = 10;
    	// 함수 호출
    	call_by_reference(&number);
        // main 함수의 number 변수는 10으로 초기화됨
    	printf("number = %d in main\n", number);
        // call_by_reference 함수 호출 시 main 함수의 number변수의 메모리 주소를 
        // 인자로 전달
    	return 0;
    }
    // 함수 정의
    void call_by_reference(int* number)
    // call_by_reference 함수에서는 매개변수 number를 통해 전달되는 메모리 주소를 받아옴
    {
    	printf("BEFORE : number = %d in call_by_value\n", *number);
    	*number = 20;
        /*
        - call_by_reference 함수의 매개변수 *number에 20 대입
    	- number 변수 앞에 있는 * 연산자 : 참조 연산자
    	- 매개변수 number 에는 메모리의 주소가 들어있으므로 이 연산자를 이용하여 
    	  그 주소로 접근 가능
        */
    }
    ```

    * main 함수로 되돌아간 후 main 함수의 number 변수를 출력한 결과는 call_by_reference 에서 대입한 20으로 변경되어 있음
    * 참조에 의한 함수 호출 방식을 이용하면 다른 함수에 있는 변수에 대한 변경도 가능
    * 이 방식을 구현하기 위해서는 C 언어의 특징이라 할 수 있는 포인터의 개념과 사용 방법을 잘 숙지해야 함

#### 4) 함수의 반환값

* return 문

  * 함수가 종료될 때 반환해야 할 수행 결과가 있으면 return 명령문 이용

  * 함수의 수행을 종료할 때 사용하는 명령문

  * 형식

    ```c
    return [반환값];
    ```

    * 함수에 반환할 값이 없을 때에는 반환값 생략 가능
    * 함수의 리턴 자료형을 void로 선언했다면 반환값은 생략해야만 함
    * 반환값은 직접 상수로 표현할 수도 있고 변수명이나 표현식도 가능함
    
  * 반환값의 예
  
    ```C
    return 10.5;		// 실수형 상수
    return n1*n2+n3; 	// 표현식
    return sum;			// 변수명
    ```
  
* 반환값 처리

  * `함수에서 반환하는 값` : 호출한 함수에서 변수로 받아와 활용

  * 변수의 자료형은 함수의 리턴 자료형과 일치시키는 것이 좋음

  * C언어에서는 형 변환이 자유로워 서로 다른 자료형이라도 대입 가능

  * 반환값이 변수에 안전하게 대입되었는지는 보장할 수 없음

  * 예

    ```C
    // 함수 선언
    float calc_time(int distance, float speed);
    
    float need_time;
    need_time=calc_time(dist, speed);
    
    // 반환값이 6.5인지 확인
    if (calc_time( 100, 0.5) == 6.5) {
        ...
    }
    // 함수의 반환값은 직접적인 처리도 가능
    ```

  * 예제 4) 소수 찾기 프로그램

    ```C
    #include <stdio.h>
    int main()
    {
    	int number;			// 1-10000
    	int prime_check;	// 2-n-1
    	int prime_count=0;	// 소수 개수
    
    	for (number = 2; number <= 10000; number++) {
    		if (is_prime(number))
    			prime_count++;
    	}
    
    	printf("소수의 개수는 %d 입니다.\n", prime_count);
    	return 0;
    }
    
    int is_prime(int number)
    {
    	int prime_check;
    	for (prime_check=2; prime_check<number; prime_check++)
    		if (number%prime_check == 0) 
    			return 0;
    	return 1;
    }
    ```

    

​    

​    