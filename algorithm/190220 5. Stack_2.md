# 5. Stack 2

### 1. 계산기

* 문자열 수식 계산
  * 1) 중위 표기법의 수식을 후위 표기법으로 변경. (스택 이용. 괄호가 사라진다.)
  * 2) 후위 표기법의 수식을 스택을 이용하여 계산.
* 1) 중위 표기법 -> 후위 표기법 변환 알고리즘
  * 피연산자 -> 출력
  * 연산자(괄호포함) -> stack의 top과 비교
    * 우선순위 높다 -> stack에 push
    * 우선순위 낮다 -> 높아질 때까지 stack에서 pop한 후 push.
    * top에 연산자가 없다 -> push
  * 토큰이 오른쪽 괄호 -> stak의 top에 왼쪽 괄호가 올 때까지 pop
    * pop한 연산자 출력
    * 왼쪽 괄호를 만나면 pop만 하고 출력하지는 않는다.
  * 중위 표기식에 더 읽을 것이 없다면 중지, 있다면 처음부터 반복한다.
  * stack에 남아있는 연산자를 모두 pop하여 출력한다.
  * **주의** : stack 밖의 왼쪽 괄호는 우선순위가 가장 높으며, 안으로 들어가면 가장 낮아진다.
* 2) 후위 표기법 수식 계산 알고리즘
  * 피연산자 -> push
  * 연산자 -> 필요한 만큼의 피연산자를 pop하여 연산하고, 결과 push
  * 수식이 끝나면, 마지막으로 pop하여 출력.

### 2. 백트래킹 (Backtracking)

* 해를 찾는 도중에 '막히면'(즉, 해가 아니면) 되돌아가서 다시 해를 찾아가는 기법.
* 최적화(optimization) 문제와 결정(decision) 문제를 해결할 수 있다.
* 결정문제 : 조건을 만족하는 해가 존재하는지의 여부 ('yes' or 'no')
  * 예) 미로찾기, n-Queen, Map coloring, Subset Sum 등
* **완전검색 + 가지치기 -> 백트래킹**
  * **이 때, 완전검색은 재귀(DFS)로 해야 한다. (가지치기 수월)**
* 백트래킹과 깊이우선탐색의 차이
  * 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면, 가지 않는다.
    * -> 시도 횟수 줄임 (Pruning, 가지치기)
  * 깊이우선탐색은 모든 경로를 추적 / 백트래킹은 불필요한 경로 조기 차단
  * 깊이우선탐색 : 경우의 수 너무 많은 문제(예) N!)에 적용하면 처리 불가능.
  * 백트래킹 알고리즘을 적용하면 일반적으로 경우의 수가 줄어들지만, 최악의 경우 여전히 지수함수 시간(Exponential Time)을 요하여 처리 불가능.
* 백트래킹은 모든 후보를 검사하지 않는다.
  * 노드의 유망성 점검 -> 유망(promising)하지 않다 -> 그 노드의 부모로 되돌아간다(backtracking).
  * 해당 노드를 포함한 경로가 해답이 될 수 없으면 그 노드는 유망하지 않다.
  * 반대로 해답의 가능성이 있으면 유망하다고 한다.
  * 가지치기(pruning): 유망하지 않은 노드가 포함된 경로는 고려하지 않는다.
* 백트래킹을 이용한 알고리즘 절차
  * 1) 상태 공간 트리의 깊이 우선 검색을 실시한다.
  * 2) 각 노드가 유망한지 점검한다.
  * 3) 만일 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 검색을 계속한다.
* powerset(모든 부분집합)을 구하는 백트래킹 알고리즘
  * -> *work 폴더에 추가 강의자료 넣어놓음*
  * a[]는 1번부터 사용 (깊이 k가 들어가자마자 1이 됨. a[k] <- c[i]를 하기 때문.)
  * backtrack(a[], k, input)
    * k: DFS 깊이 (현위치)
    * input: 원하는 깊이
  * make_candidates(a[], k, n, c[], ncands)
    * c[] = [1(True), 0(False)] -> 원소의 개수가 많은 것부터 구해짐.
  * 재귀 깊이우선탐색
  * 기본 틀이라 불필요한 변수도 받고있음. 문제에 따라 조정하면 됨.
* 백트래킹을 이용하여 순열 구하기
  * 접근방법은 부분집합 구하기와 유사하다.
  * backtrack(a[], k, input)
  * make_candidates(a[], k, n, c[], ncands) 
    * c[] -> 이전에 넣지 않았던 값의 세트.
    * in_perm[]에 visited를 체크해놓고 제외한 값을 c[]에 넣어준다.
* 가지치기 예) 원소의 합이 10인 부분집합 구하기
  * if a[k]: backtrack(a, k, input, sum+data[k])
  * else: backtrack(a, k, input, sum)
  * -> if sum > 10: return : 더 깊이 들어가지 않고 다시 위로 올라가 다른 가능성을 탐색.

### 3. 분할정복

> 1805년 12월 2일 아우스터리츠 전투에서 나폴레옹이 사용한 전략에서 유래.

* 설계 전략
  * 분할(Divide): 해결할 문제를 여러 개의 작은 부분으로 나눈다.
  * 정복(Conquer): 나눈 작은 문제를 각각 해결한다.
  * 통합(Combine): (필요하다면) 해결된 해답을 모은다.
* 거듭제곱(Exponentiation)
  * 분할정복 -> O(log2n)
  * 파이썬은 그냥 '**' 쓰면...
* 퀵 정렬
  * 주어진 배열을 두 개로 분할하고, 각각을 정렬한다.
  * 분할할 때, 기준 아이템(pivot item) 중심으로 작은 것은 왼편, 큰 것은 오른편.
  * 합병정렬은 퀵정렬과 다르다. 그냥 두 부분으로 나누며, '합병'이란 후처리 작업이 필요하다.
  * 1) 피폿 선택: 왼쪽 끝 / 오른쪽 끝 / 임의의 세 값 중 중간 값
  * 2) 왼쪽부터 작은 값을 찾고 오른쪽부터 큰 값을 찾아 교환. i과 j가 교차하기 전까지.
  * 3) 피봇과 경계를 교환
  * -> 경계의 양쪽 반반에 대해, 1)부터 반복
  * 최악의 경우, O(n**2). 평균 복잡도가 O(nlogn)이기 때문에 '빠른' 정렬.

### 4. 실습

* 토너먼트: 분할정복을 재귀로, return 있음.
* 배열최소합: 백트래킹.

