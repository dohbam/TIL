## 2. 배열 2 (Array 2)

#### 2.1 배열: 2차 배열

* 2차원 배열
  * 1차원 List를 묶어놓은 List
  * 2차원 이상의 다차원 List는 차원에 따라 Index를 선언한다.
  * 2차원 List의 선언: 세로길이(행의 개수), 가로길이(열의 개수)를 필요로 한다.
  * Python에서는 데이터 초기화를 통해 변수선언과 초기화가 가능하다.
* 배열 순회
  * n X m 배열의  n*m개의 모든 원소를 빠짐없이 조사하는 방법
  * 행 우선 순회: i in range(len(Array)) > j in range(len(Array[i])): i행 j열, i행 j+1열...
  * 열 우선 순회: j in range(len(Array[0])) > i in range(len(Array)): i행 j열, i+1행 j열...
  * 지그재그 순회
* 델타를 이용한 2차 배열 탐색
  * 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법 (8방향도 가능)
  * x, y 좌표 -> a\[y\]\[x\]
  * dx = [0, 0, -1, 1] : 좌, 우
  * dy = [-1, 1, 0, 0] : 상, 하
  * x in range(len(ary)) > y in range(len(ary[x])) > i in range(4) > x + dx[i], y + dy[i] 로 네 방향 테스트
  * 대각선: dx = [-1, 1, -1, 1], dy = [-1, -1, 1, 1]
  * my) 전방향 -1, 0, 1로 이중 for문 돌리는 것도 되지 않을까? [0, 0]만 무시하고.
  * tip) 벽 체크 함수 만들거나 continue 로 함수 없이 해결 하는 것도.
* 전치 행렬
  * i in range(n): j in range(n): if i < j : arr\[i]\[j], arr\[j]\[i] = arr\[j]\[i], arr\[i]\[j] : 반만. 다 하면 다시 원본이 되지.

#### 2.2 부분집합 생성

* 부분집합 합(Subset Sum) 문제

  * 유한 개의 정수로 이루어진 집합의 부분집합 중 합이 0이 되는 경우가 있는지 알아내는 문제.
  * 완전검색 기법

    * 부분집합 생성
      * 부분집합의 수: 2^n개 (공집합 포함)
      * 각 원소를 부분집합에 포함 or 포함x 두 가지 경우를 모든 원소의 수만큼 곱한 것.
      * bit = [0]*n 에 0또는 1을 넣은 모든 경우의 수 구현
        * 16진수 한 자리가 2진수 4자리 표현 가능.  두 자리면 2진수 8자리. 
        * 그래서 컴퓨터는 16진수 사용한다. 16진수 두 자리: 2bit = 1byte
          * 예) 컴퓨터 물리적 주소, IP 버전6
      * if bit[i]: print(data[i], end=" "):print() 로 모든 부분집합 찍을 수 있다.
  * 비트 연산자

    * 피연산자가 정수일 때 사용 가능.
    * 피연산자를 2진수로 바꾸어 연산 후 정수로 결과값 반환.

      * `&`: 비트 단위로 AND 연산

      * `|`: 비트 단위로 OR 연산

      * `<<`: 피연산자의 비트 열을 왼쪽으로 이동

      * `>>`: 피연산자의 비트 열을 오른쪽으로 이동
    * 2진수를 사용하기에 연산속도가 빠르다. (컴퓨터는 2진수 좋아함)
    * 사용 예)
      * 1 << n : 2^n, 원소가 n개일 경우 모든 부분집합의 수
      * i & (1<<j) : i의 j번째 비트가 1인지 아닌지 리턴
        * 예) 7&(1<<j): j는 0부터 3까지: 0111이므로 순서대로 1, 1, 1, 0
    * 부분집합 생성
      * n = len(arr) : 원소의 개수
      * i in range(1<<n): 부분집합의 개수
        * j in range(n): 원소의 개수
          * if i&(1<<j): i의 j번째 비트가 1이면
            * print(arr[j], end=", "): j번째 원소 출력
            * 위의 방법으로 생성할 땐, 0001이 arr의 마지막 원소를 찍지만,
              * 011: 두 번째, 마지막 원소 (그 자리)
            * 이 경우엔 '번째' 원소부터 출력하므로 arr의 첫 번째 원소를 찍는다는 차이점.
              * 011: 첫 번째, 두 번째 원소 (그 순서)
  * 가지치기는 재귀로 넣는 것. 반복문을 이용한 완전검색이 재귀보다 빠르지만, 가지치기를 못하므로 결국은 재귀가 더 빠른. 나중에 배울 동적계획법도 있다.
  * 예제 2) 공집합 포함 않기 위해 첫번째 부분집합 range에서 1 부터 시작하도록. 

#### 2.3 바이너리 서치(Binary Search)

* 검색
  * 저장된 자료 중 원하는 항목을 찾는 작업
  * 목적하는 탐색 키를 가진 항목을 찾는 것
    * 탐색 키(search key): 자료를 구별하여 인식할 수 있는 키
  * 검색의 종류
    * 순차 검색(sequential search)
    * 이진 검색(binary search)
    * 해쉬(hash)
* 순차 검색(Sequential Search)
  * 일렬로 되어 있는 자료를 순서대로 검색하는 방법
  * 가장 간단, 직관적.
  * 배열, 연결 리스트 등 순차구조(1:1)로 구현된 자료구조에서 원하는 항목을 찾을 때 유용.
  * 알고리즘이 단순하여 구현이 쉽지만, 검색 대상의 수가 많은 경우 수행시간이 급격히 증가하여 비효율적.
  * 
    * 1:n - 비선형구조. 트리. 
    * n:n - 계층관계 없음. 그래프.
  * 두 가지 경우
    * 정렬되어 있지 않은 경우
    * 정렬되어 있는 경우
  * 시간복잡도 O(n)
  * 순서대로 검색 대상과 같은 원소가 있는지 비교 - 찾으면 원소의 인덱스 반환 - 끝까지 못찾으면 검색 실패
  * 자료가 정렬되어 있는 경우 평균 비교 회수가 반으로 줄어들지만, 여전히 시간복잡도는 O(n)
* 이진 검색(Binary Search)
  * 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법.
  * 목적 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행. 검색 범위를 반으로 줄여가면서 검색을 수행.
  * 이진 검색을 하기 위해서는 자료가 정렬된 상태여야 한다.

#### 2.4 셀렉션 알고리즘 (Selection Algorithm)

* 인덱스
  * Database에서 유래, 테이블에 대한 동작 속도를 높여주는 자료 구조.
  * Database 외 분야에서는 Look up table 등의 용어 사용.
  * 인덱스를 저장하는 데 필요한 디스크 공간은 보통 테이블을 저장하는데 필요한 디스크 공간보다 작다.
    * 키 필드만 갖고 테이블의 다른 세부 항목은 갖지 않기 때문.
  * 배열을 사용한 인덱스
    * 대량 데이터의 성능 저하 문제를 해결하기 위해 배열 인덱스를 사용할 수 있다.
    * 원본 데이터 배열과 별개로 배열 인덱스 추가, 상대적으로 크기가 작은 인덱스 배열 정렬. 속도 개선.
* 셀렉션 알고리즘(Selection Algorithm)
  * 저장되어 있는 자료로부터 k번째로 큰, 혹은 작은 원소를 찾는 방법.
  * 최소값, 최대값, 혹은 중간값을 찾는 알고리즘을 의미하기도.
  * 선택 과정
    * 1) 정렬 알고리즘을 이용하여 자료 정렬
    * 2) 원하는 순서의 원소 가져옴
    * 굳이 다 정렬하지 않고 큰, 혹은 작은 원소를 k번째까지만 찾으면.
    * k가 비교적 작을 때 유용, O(kn)의 수행시간 필요.

#### 2.5 선택 정렬(Selection Sort)
  * 주어진 자료들 중 가장 작은 값의 원소부터 차례로 선택하여 위치를 교환하는 방식.
  * 셀렉션 알고리즘을 전체 자료에 적용한 것.
  * 정렬 과정
    * 주어진 리스트 중 최소값 찾기
    * 그 값을 리스트 맨 앞에 위치한 값과 교환
    * 맨 처음 위치를 제외한 나머지 리스트 대상으로 과정 반복.
  * 시간복잡도: O(n^2)
  * i in range(0, len(a)-1): 마지막 하나 남았다면 걔가 최대값이므로 len(a) -1까지
    * min = i: min 초기화
    * j in range(i+1, len(a)): i에서 시작 i보다 오른쪽에 있는 애들과 비교
      * if a[min] > a[j]:
        * min = j
    * a[i], a[min] = a[min], a[i]

#### 2.6 실습

* 달팽이
  * 벽 체크 - 방향 전환
  * 이중리스트 초기화 주의.
* sum
  * 대각선 합은 for문을 한 번만 돌리면 되지.
* 특별한 정렬
  * t) 선택정렬 이용할 것. 짝, 홀 나누어.



