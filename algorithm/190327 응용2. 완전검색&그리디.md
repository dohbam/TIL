# 완전검색 & 그리디

* 완전검색(재귀 DFS) + 가지치기 -> Back Tracking
  * 순열
  * 조합
  * 부분집합

## 반복과 재귀

* 반복과 재귀는 유사한 작업
  * 반복을 재귀로 바꿀 수 있다.
  * 재귀를 반복으로 바꾸는 건 경우에 따라 다르다.
* 반복 구조 (while문)
  * 초기화 (loop initialization)
  * 조건검사 (check control expression)
  * 명령문 실행 (action)
  * 업데이트 (loop update)
    * 무한 루프(infinite loop)가 되지 않도록 조건이 거짓(false)이 되게 함.
  * (python에서 for문의 i는 임의조작 불가능하므로 반복횟수가 정확하지 않을 땐 while문을 사용한다.)
  * (python에는 do-while문이 없으므로 while True로 시작하여 break 조건문을 넣어준다.)
* 재귀적 알고리즘
  * basis part
  * inductive part
* 재귀 함수(recursive function)
* 반복 or 재귀
  * 재귀: 알고리즘 설계가 간단. 그러나 더 많은 메모리와 연산 필요.
  * 입력값 n이 커질수록 재귀는 반복에 비해 비효율적일 수 있다.

## 완전검색기법

* Baby-gin Game
  * 완전검색, 순열
  * (그리디: 카운팅)
  * 고지식한 방법: brute-force
    * 간단하고 쉬운 접근법
    * 빠른 설계, 낮은 효율성
* 완전검색으로 시작해야 한다.
  * 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾지 못할 확률이 작다.
  * 이를 기반으로 그리디나 동적 계획법을 이용하여 효율적인 알고리즘을 찾을 수 있다.
  * 우선 완전검색으로 접근하여 해답을 도출한 후(입력의 크기 작게), 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직하다.
  * **재귀로 짜서 가지치기**
* 완전검색
  * 특정 조건을 만족하는 경우나 요소를 찾는 문제
  * 순열, 조합, 부분집합 등 조합적 문제

## 조합적 문제

* 여행사 BIG sale!
  * 1: 순열 문제 - 최단 경로
  * 2: 조합 문제 - 최대 숙박비
  * 3: 부분집합 문제 - 최다 도시
* 순열
  * 순열, 중복순열, Factorial(nPn)
  * nPr = n*n-1Pr-1
  * (컴퓨터는 0->n보다 n->0을 빨리 계산한다. (최적화, 나중 문제))
  * 상태공간트리를 그릴 줄 알아야 한다.
* 순열 생성 방법
  * 사전적 순서 (Lexicographic-Order)
  * 최소 변경 (Minimum-exchange requirement)
    * 교회 종소리 패턴과 유사
    * Johnson-Trotter 알고리즘
  * 재귀 호출을 통한 순열 생성
    * 0에서부터 n까지 swap해가며 - 앞에서부터 채워지는 시스템.
    * 중복순열은 이전에 배운 코드로 해야 함
* 부분집합
  * 원소들의 그룹에서 최적의 부분집합을 찾는 것
    * 예) 배낭 짐싸기
  * 자신과 공집합을 포함한 모든 부분집합의 개수 2^n개
* 부분집합 생성 방법
  * 바이너리 카운팅을 통한 사전적 순서(Lexicographical Order) (비트연산자 이용)
  * 재귀: chk 배열로 포함/불포함
* 조합
  * nCr = n-1Cr-1 + n-1Cr

## 탐욕 알고리즘

* 문제: 거스름돈 줄이기
* 선택할 때마다 그 순간에 최적이라고 생각되는 것을 선택해나가는 방식.
* 근시안적인 방법 -> 최적이라는 보장이 없다. 아예 답이 틀릴 수도 있음.
* 지역적으로는 최적이지만, 최종 답은 아닐 수 있음.
* 배낭 짐싸기(Knapsack)
  * 0-1 Knapsack
    * 완전검색으로 모든 부분집합
    * 총 무게가 W를 초과하는 집합을 버리고 나머지 집합 중 총 값이 가장 큰 집합을 선택
    * 물건 개수가 증가하면 시간복잡도가 지수적으로 증가한다.
  * Greedy
    * 실패 실패 실패
  * Fractional Knapsack
    * 물건을 쪼개서 넣을 수 있다.
    * -> greedy로 해결 가능
* 회의실 배정하기
  * 활동 선택(Activity-selection problem) 문제
* 대표적인 탐욕 기법 알고리즘
  * Prim
  * Kruskal
  * Dijkstra
  * Huffman tree & code

## 실습

* 완전검색(재귀DFS) + 가지치기 => BT
  * \+ memoiztion
* 순열(, 중복순열), 조합(, 중복조합), 부분집합을 구현할 수 있어야.
* sum 등을 넘기면서 계산하지 않고 대입을 해버리면 되돌아왔을 때 빼줘야 함.
  * sum = sum+data[k] 하지 않고 powerset(n, k+1, sum+data[k]) 하는 이유
* tip) `값을 변경하지 않을 상수 전역변수`나 `레퍼런스 타입 전역변수`는 굳이 global로 넘기지 않아도 된다. (상수값은 보통 대문자 변수명을 쓴다.)  