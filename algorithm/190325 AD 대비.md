# AD

* AD 문제 유형
  * idea성 문제. (for)
  * DFS
  * BFS
* DP까지는 안 나옴. 완전탐색.
* 1일
  * 정렬
  * 이진탐색
  * 그리디
  * BFS
* 2일
  * 재귀함수
  * Flood Fill
  * DFS
  * 순열
  * 조합

## 정렬

* n^2

  * Bubble 등 단순 정렬
    * 예) 작은 것부터 3개만 뽑기. 이런 건 세 번만 돌면 되지.
    * i: 회전, 정렬대상 / j: 비교대상
    * 삽입정렬은 이미 정렬된 리스트에 나를 끼워넣을 때

* nlogn

  * Quick
    * 2차 정렬에 대비해 맨 앞이나 맨 뒤를 기준으로 잡는 게 좋음
    * 최악의 경우 n^2 (기준으로 쪼개지지 않을 경우)
    * 기준: pivot, 비교대상: left, 교환대상: target
      * pivot은 end, target은 start, L도 start부터 시작
      * 크면 target은 두고 l이동. 
      * 작으면 l과 target 교환 후 target 위치를 한 칸 올림.
      * 한 회전이 끝나면 target 기준으로 왼쪽에는 pivot보다 작은 숫자가, 오른쪽에는 큰 숫자가 들어가 있음.
      * 마무리로 target과 pivot 교환
      * target을 기준으로 왼쪽과 오른쪽을 재귀.
      * start >= end일 때 return
  * Merge
    * 좀 더 안정적.
    * 임시 buffer 필요
    * s == m, e == s+1 까지 내려가 원소가 두 개일 때 교환
    * [s:m], [m+1:e] 각각을 i와 j로 루프
    * 작은 걸 넣고 넣은쪽 idx를 하나 증가
    * 둘 중 하나가 idx 벗어나면 남아있는 쪽을 그대로 버퍼에 넣으면 됨.
  * 둘 중에 하나는 암기해놓을 것

* 포장

  * 2개만 정렬해서 쓸 수 있지.

    ```python
    for i in range(k, k+2):
        for j in range(i+1, N):
            if arr[i] > arr[j]:
                arr[i], arr[j] = arr[j], arr[i]
    ```

  * 또는 insert도 쓸 수 있지.

## 이진탐색

* 숫자찾기
  * 정렬된 리스트에서 원하는 값 찾기
  * s, e, m=(s+e)//2
  * arr[m] 와 값 비교, 크면 오른쪽(s=m), 작으면 왼쪽(e=m) 탐색
* 구간을 구하고 싶을 때
  * 정렬된 리스트에서 하한과 상한을 찾아 idx 계산.
  * 같은 값이 여러 개일 경우
    * 원하는 하한을 찾은 후 왼쪽 탐색
    * 원하는 상한을 찾은 후 오른쪽 탐색
* 도약
  * 두 번째 점프를 시도할 시작값과 끝값을 위의 방법으로 찾아 idx 차로 계산하자.

## BFS

* tip) 리스트보단 튜플을 쓰는 쪽이 시간이 절약된다.
* 최단거리 문제에 많이 사용
* 완전탐색에도 사용
  * 맵이 클 때 유용
* 큐에 넣을 때 visit
* my) visit에 depth 넣고 싶으면 visit[전] + 1 하면 됨

## 재귀

* 1) parameter가 중요
* 2) 함수가 반복해서 할일을 찾아야
* 3) 반복을 멈출 return 시점의 조건을 찾아야
* 함수 호출 시점, 함수가 끝나서 돌아가는 시점 등을 잘 생각해야.
* n이 10개 내외인 문제만 재귀로 짠다. 

## Flood Fill

* 

## DFS

* 

## 순열

* parameter
  * ex) sumi
* depth

## 조합

* 이중재귀
* cnt, sum 등 필요한 parameter를 같이 보내서 가지치기로 사용

## 중복조합

* 다중재귀

## 심화

* 필요한 정보를 파라미터로 같이 들고 다니는 거
* 다중재귀 - 경우의 수를 재귀 호출로 파고들어가는 것
* 주사위던지기 - for문 돌리는 다중재귀로 설계할 수 있음. 파라미터 들고 들어가면서.
  * 문제를 읽어보고 내가 이해한 구조로 짜면 됨.

