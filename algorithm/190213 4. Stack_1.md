# Stack

* 들어가기 전에

```text
code
--------
data(전역변수)
--------
heap(참조형)
- - - - -
stack(지역변수)
```

* tip) python에서 reference type 변수는 global 선언하지 않아도 함수 안에서 접근, 변경 가능하다.

### 1. Stack

* 스택(stack)의 특성

  * 자료를 쌓아 올린 형태의 자료구조
  * 스택에 저장된 자료는 선형 구조를 갖는다.
    * 선형구조: 자료 간의 관계가 1대 1 관계
    * 비선형구조: 자료 간의 관계가 1대 N 관계 (예) 트리)
      * 트리: 정점(node)이 간선(edge)으로 연결되어 있다. 부모자식관계(1대 N).
        * 자식이 2개 이하인 트리: binary tree. 
        * 주로 트리는 바이너리트리를 의미하며, 그 외는 그래프로 취급.
        * DFS를 축소한 순회방법으로 탐색.
      * 그래프: N대 N관계. Vertex가 간선으로 연결.
        * 그래프 중 계층구조가 있는 게 트리. 그래프의 부분집합이 트리. 
        * 깊이우선탐색(DFS)와 너비우선탐색(BFS)으로 탐색.
  * 스택에 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있다.
  * 마지막에 삽입한 자료를 가장 먼저 꺼낸다.
  * 후입선출(LIFO, Last-In-First-Out)

* 스택의 구현

  * ADT(Abstract Data Type, 추상자료형) - 자료구조(변수)와 연산(메소드) 필요.

  * 자료구조

    * 자료를 선형으로 저장할 저장소
    * C언어에서는 배열 사용 가능
    * 저장소 자체를 스택이라 부르기도 한다.
    * 스택에서 마지막 삽입된 원소의 위치를 top이라 부른다.

  * 연산

    * 삽입(push): 저장소에 자료 저장
    * 삭제(pop): 저장소에서 자료 꺼내기. 삽입한 자료의 역순으로 꺼낸다.
    * isEmpty: 스택이 공백인지 아닌지 확인하는 연산
    * peek: 스택의 top에 있는 item(원소)을 반환하는 연산

  * push

    * python
      * append 메소드를 통해 리스트의 마지막에 데이터를 삽입. 크기 조건 불필요.

    ```python
    def push(item):
        s.append(item)
    ```

    * C style
      * stack 사이즈는 보통 아주 넉넉하게 만들지만, 가득 찼을 때의 제한조건 필요.

  * pop

    * python
      * pop 메소드 이용. -1로 읽으면 되므로 top 변수 불필요. 
      * 비어있을 때 제한조건만 있으면 됨.

    ```python
    def pop():
        if len(s) == 0:
            return "Stack is empty!"
        else:
            return s.pop(-1)
    ```

    * C style
      * stack이 비어있을 때, 제한조건 필요.
      * top 변수 이용, 실제로 값이 삭제되는 건 아님. 
      * 유효하지 않은 값이 되어 새로 push하면 덮어씌워진다.
      * 하드디스크 원리도 이러하다. 복구가 가능한 이유. 
        * 이 때문에 디가우징(강한 자기장에 노출)을 한다. 

* 스택 구현 고려 사항

  * 1차원 배열
    * 구현이 용이하지만, 스택의 크기를 변경하기 어렵다. (c style)
    * (python은 상관 없음)
  * 해결 방법 (c)
    * 저장소를 동적으로 할당하여 스택을 구현한다.
    * 동적 연결리스트를 이용하여 구현하는 방법.
    * 구현이 복잡하지만, 메모리를 효율적으로 사용한다. 

* 스택의 응용 1: 괄호 검사

  * 괄호의 종류: 대괄호[], 중괄호{}, 소괄호()
  * 조건
    * 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 한다.
    * 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다.
    * 괄호 사이에는 포함 관계만 존재한다. ({[]}) 가능.

* 스택의 응용 2: function call

  * 프로그램에서의 함수 호출과 복귀에 따른 수행 순서 관리
    * 가장 마지막에 호출된 함수가 가장 먼저 실행 완료 후 복귀하는 후입선출구조이므로, 후입선출구조의 스택을 이용하여 수행순서 관리.
    * 함수 호출이 발생하면 호출한 함수 수행에 필요한 지역변수, 매개변수 및 수행 후 복귀할 주소 등의 정보를 스택 프레임(stack frame)에 저장하여 시스템 스택에 삽입.
    * 함수의 실행이 끝나면 시스템 스택의 top 원소(스택 프레임)를 삭제(pop)하면서 프레임에 저장되어 있던 복귀주소를 확인하고 복귀.
    * 함수 호출과 복귀에 따라 이 과정을 반복하여 전체 프로그램 수행이 종료되면 시스템 스택은 공백 스택이 된다.

### 2. 재귀호출

* 자기 자신을 호출하여 순환 수행하는 것
* 예) factorial, 피보나치 수열
* 프로그램의 크기를 줄이고 간단하게 작성할 수 있지만, 스택에 계속 쌓이므로 프로그램 부담이 크고 속도가 느리다.
* 완전검색 시 for문은 가지치기를 할 수 없으므로, 재귀를 이용.
* 재귀
  * 1) basis (기본) : 멈추는 부분
  * 2) inductive (유도) : 자기 호출
* 깊이우선탐색(DFS)처럼 돈다.
* 피보나치 수열
  * 재귀함수 알고리즘 문제점: 엄청난 중복 호출 O(2**n)

### 3. Memoization

> 컴퓨터 프로그램을 실행할 때, 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술. 동적 계획법의 핵심이 되는 기술이다.
>
> 'momoization'을 글자 그대로 해석하면 '메모리에 넣기(to put in memory)'라는 의미이며, 라틴어 memorandum에서 파생되었다. 동사형은 memoize이다. (memorization과 혼동하지 않기)

* 피보나치 수열
  * fibo(n)을 계산하자마자 저장하면(memoize), 실행시간을 O(n)으로 줄일 수 있다.
  * 이전에 구하지 않은 값만 구하므로. 

### 4. DP

> 동적 계획(Dynamic Programming) 알고리즘은 그리디 알고리즘과 같이 **'최적화 문제'**를 해결하는 알고리즘이다.
>
> 동적 계획 알고리즘은 먼저 입력 크기가 작은 부분 문제들을 모두 해결한 후, 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결, 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘이다.

* 피보나치 수 DP 적용
  * 피보나치 수는 부분문제의 답으로 본 문제의 답을 얻을 수 있으므로 최적 부분 구조에 해당.
  * 해결 과정
    * 1) 문제를 부분 문제로 분할
    * 2) 가장 작은 부분 문제부터 해를 구한다.
    * 3) 결과를 테이블에 저장하고, 테이블에 저장된 부분 문제의 해를 이용하여 상위 문제의 해를 구한다.
  * 내부에서 함수 호출이 한 번도 일어나지 않는다. - stack over flow 가능성 down.
  * 배열 한계까지 
* DP의 구현 방식
  * recursive(재귀적) 방식
  * iterative(반복적) 방식
  * memoization을 재귀적 구조에 사용하는 것보다 반복적 구조로 DP를 구현한 것이 성능면에서 보다 효율적.
  * 재귀적 구조는 내부에 시스템 호출 스택을 사용하는 오버헤드가 발생하기 때문.

### 5. DFS(깊이우선탐색)

* 비선형구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요하다.
* 두 가지 방법
  * 깊이 우선 탐색(Depth First Search, DFS)
  * 너비 우선 탐색(Breadth First Search, BFS)
* DFS(깊이우선탐색)
  * 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊게 탐색
  * 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서
  * 다른 방향의 정점으로 탐색을 반복
  * 결국 모든 정점을 방문하는 순회 방법
* 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이우선탐색을 반복해야 하므로
  * -> 후입 선출 구조의 스택 사용

* DFS 알고리즘
  * 1) 시작 정점 v를 결정하여 방문한다.
  * 2) 정점 v에 인접한 정점 중
    * a) 방문하지 않은 정점 w가 있으면, 정점 v를 스택에 push하고 정점 w를 방문한다.
      * 그리고 w를 v로 하여 다시 2)를 반복한다.
    * b) 방문하지 않은 정점이 없으면, 탐색의 방향을 바꾸기 위하여 스택을 pop하여 받은 가장 마지막 방문 정점을 v로 하여 다시 2)를 반복한다.
  * 3) 스택이 공백이 될 때까지, 2)를 반복한다.
* DFS 알고리즘 - 반복 *(강의자료 수정된 부분 work/4.stack 에 넣어놓음)*
  * DFS 예) visited check: A - C - E - F - G - D - B (사전 순으로 넣었을 경우)
  * push로 쌓고 pop으로 꺼내 방문한 적 없으면 방문체크, 인접한 정점 중 방문하지 않은 점 push -> stack이 빌 때까지 반복
  * 방문처리를 할 때, 내가 하고 싶은 작업을 하는 것.
* DFS 알고리즘 - 재귀
  * v 방문 설정, 인접한 모든 정점에 대하여 방문체크가 되어있지 않으면, 재귀로 돌린다.
    * 스택에 넣지 않음, 대신 함수가 쌓임.
  * DFS 예) visited check: A - B - D - F - E - C - G (사전 순으로 처리했을 경우)
* DFS - 연습문제 (방향성, 가중치 없음)
  * 1,2,1,3,2,4,2,5,4,6,5,6,6,7,3,7
  * 방법1) 인접행렬
    * (1,2) (1,3) (2,4) (2,5) (4,6) (5,6) (6,7) (3,7) -> 1로 체크(가중치 x)
    * (2,1) (3,1) (4,2) (5,2) (6,4) (6,5) (7,6) (7,3) -> 1로 체크(가중치 x)
    * 방향성이 없으므로, 전치행렬이 나온다.
    * 차수를 확인할 수 있다. (방향성이 없으므로, 이 경우 진출차수 == 진입차수)
    * 인접한 정점도 확인 가능.
  * 방법2) 인접정점행렬
    * (1: 2, 3), (2:1, 4, 5), (3: 1, 7), ... 
  * 방법 1 사용, 인접 행렬을 만든다.
  * -> dfs 함수(재귀 or 반복)에서 순서를 뽑아본다.

### 6. 실습

* Ladder
  * my) 조금 많이 길어서
  * 병석) 보고 수정함

* 2.14 복습

  * 깊이우선 - 스택
  * 너비우선 - 큐
  * 부모자식관계인 트리의 경우, visited를 체크하지 않아도 됨. 축소된 DFS.
  * 피보나치
    * 재귀 DP (memoization) : top-down
    * 반복 DP: bottom-up
  * 주의: 파이썬은 함수 내부 변수가 외부 변수에 영향을 미치므로 변수명과 변수 사용에 주의해야 한다. 원래 함수 내부에서 쓴 변수는 밖에서 쓰거나 영향을 미치게 하면 안 됨.

  ```python
  i = 500
  for i in range(5):
      i += 1
      print(i)
  # 결과가 5가 나온다. i가 range를 돌며 계속 초기화되므로 마지막 결과인 4+1이 출력됨.
  # 파이썬만 그러니까 주의할 것.
  ```

  * ladder2, 미로 풀어보기

* 종이붙이기

  * my) |, ㅁ, = 를 스택에 쌓으면서 N까지 갔다가 하나 빼고 다른 거 넣어보면서 최종결과만 카운트하는 건가? for i in [a, b, c]: return f(L+i) 이렇게? if sum(L) >= N이면 result체크, 있으면 함수 끝내고 없으면 추가하고 f(0)부터 다시 시작해야 하나? 
    * 아니면 visited를 초기화해가면서 sum(L) <= N 동안 반복DFS로 계속 도는 거? visited 자체를 스택에 쌓아야 할 것 같은데. 끝까지 쌓고 마지막에 넣은 걸 빼내서 a면 b 또는 c를 가야 하는 거. N이면 기록하고 넘쳤으면 와서 빼고 c 넣어보고 또 넘쳐서 a, b, c 다 넣어봤으면 하나 더 빼는 걸 해야 해. cnt 넣어서 3 되면 두 개 빼라고 할까. 
    * 아니다, 트리니까 더 쉽게 하는 방법이 있을 거야. 1 - 2, 3, 4 - 5, 6, 7 / 8, 9, 10 / 11, 12, 13 - 14 ... 엄마*3(-1, +0, +1)
    * 아니면 나를 포함해서 1,2,3 다 차 있는 테이블 있으면 되는 거 아닌가. 방문횟수로 총합 구할 수 있고, 스택으로 1, 2, 3만 채우고 비우면서 하면 되지 않을까. 방금 꺼낸 것만 아니면 넣어도 됨! 하는 식으로.
    * while sum <= N - for[1, 2, 3] - if pop != i - push
  * hint) 재귀

* 괄호 검사

* 그래프 경로

  * hint) DFS

* 반복문자지우기

* tip)

  * cycle이 없다. -> visited를 찍지 않아도 된다.