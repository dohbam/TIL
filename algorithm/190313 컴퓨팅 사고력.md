# 컴퓨팅 사고력

## 0. 서론 - 프로그래밍과 논리/수학

> - 프로그래밍 언어(문법, 라이브러리)는 도구일 뿐
> - 논리(Hard Logic), 알고리즘(Algorithm)이 중요

* 논리(Hard Logic)와 직관(Soft Logic)
  * 직관의 장점: 익숙한 상황에서 빠르다.
  * 직관의 단점
    * 정확하지 않다. (익숙한 상황에서도 틀릴 수 있다.)
    * 강한 착각을 일으킨다.
  * 직관은 논리적으로 부정확한 표현을 사용하지만, 어떤 의미인지 모든 사람이 이미 알고 있다는 가정이 존재하기에 일상 생활에서는 유용하게 사용된다.
* 프로그래밍은 Hard Logic을 사용한다.
  * 프로그래밍 언어의 표현은 모두 논리학에서 나옴
  * 알고리즘을 이해하기 위해 Hard Logic 필요
* Soft Logic으로 알고리즘을 이해하려고 하면 오해가 발생한다.
* 논리연습
  * p -> q에서 p가 거짓이면, q 명제의 참/거짓 여부에 상관 없이 해당 명제식은 참이다.
  * p -> q에서 q가 참이면 대우 명제 ~q -> ~p가 ~p의 참/거짓 여부에 상관 없이 참이므로 본 명제식도 참이다.
  * p -> q가 거짓일 때, (T->F) 
    * ~p -> q : 참 (F ->)
    * p V q (합집합) : 참
    * q -> p : 참 (F -> T)
  * 역, 이, 대우
  * 진리표
* 증명
  * 정확한 명제식으로 표현 가능해야 함
  * 보통 정확한 명제식까지 쓰진 않지만, 근본적으로 명제식으로 바꿀 수 있어야.
  * p -> q와 p <-> q를 혼동하여 오해 발생
  * 귀납법, 귀류법
* 수학적 귀납법
  * 기본형: P(1)이 참이고, P(n) -> P(n+1)이 참이면 P(n)은 모든 자연수 n에 대해 참이다.
  * 강한 형태: P(1)이 참이고, P(1)^P(2)^...^P(n) -> P(n+1)이 참이면 P(n)은 모든 자연수 n에 대해 참이다.
  * 증명 가능한 명제를 만들어야 한다.
    * 예) sum(x)가 리턴하는 값은 1+2+...+x와 항상 같다.
    * sum(1)이 리턴하는 값은 1이다. 
    * sum(x-1)이 1+...+(x-1)을 리턴하면 sum(x)는 1+...+x를 리턴한다.
    * *sum(x-1)을 블랙박스로 보는 것이 이해에 도움될 수 있음*

## 1. 논리와 증명

* 종이에 연습

## 2. 수와 표현

* 설명
  * 컴퓨터는 0 과 1을 표현할 수 있는 비트들을 모아 수를 표현
  * 바이트(byte): 정보의 최소단위. 영문자 한 자를 나타냄.
    * *인터넷속도의 단위는 bps(bit per sec). 1기가여도 실제론 100메가정도 속도인 것.*
    * ASCII(7bit)+Parity Bit
  * k개의 비트 -> 2^k 가지의 값 표현 가능
  * *음수의 표현*
    * 1) 부호와 절대값 -> 3bit : -3 ~ 3
    * 2) 1의 보수 -> 3bit : -3 ~ 3
    * 3) 2의 보수(1의보수 + 1) -> 3bit : -4 ~ 3
      * 장점: 빼기가 가능
  * 어떤 값 n을 표현하려면 약 logn 비트가 필요. (2^k >= n+1)
    * *컴퓨터에서 log의 밑은 2*
  * 32bit 컴퓨터의 주소 공간은 2^32 = 약 40억 개 주소 = 약 4GB
    * 32bit 컴퓨터 -> 4byte를 한 번에 access
    * C에서 4byte int 처리가 1byte char보다 빠르다.
* 문제
  * 2진수 표현에서 logn 비트로 표현할 수 있는 숫자 범위는? - 2^n가지의 값
  * 값 비교
    * 2n < n^2
    * 2^(n/2) < 3^(n/2)
    * 2^(nlogn)=n^n > n!
    * log2^2n=2n < n^3/2

