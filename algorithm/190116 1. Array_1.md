# 알고리즘 기본 과정

> 2019.01.16 ~ 2019.02.12

> 김한욱, hanoogi@naver.com, 010-5491-9784

> 교재: APS(Algorithm Problem Solving)

* Test
  * IM > AD > PRO > Expert
  * S 직군은 AD 필수
  * 우리의 1차 목표는 IM. 3회 응시 기회.
  * IM: 다중 for문 + Array(List)
  * AD: 완전검색(DFS) + 재귀함수(가지치기: Back Tracking)
  * PRO: DP(Dinamic Programming: 동적 계획법) -> 변경됨 -> main함수 제공 후 함수 구현
  * Expert: 100명 중 2명만 합격. 소스코드, 실행속도 등 모두 따져봄.
  * AD부터 library 사용 불가. python은 가능하지만, 이론 시간에는 사용하지 않음.
  * java가 느려서(.exe 없이 중간파일만 나오기 때문에 실행환경을 맞춰줘야. 대신, 그것만 맞춰주면 linux, window에서 모두 잘 돌아감. C#도 같은 특징.) AD 과정은 C와 C++만 있음. 
  * SW Expert Academy. 문제, 이러닝, 테스트 제공.

* Course

  * 배열, 문자열, 스택, 큐, linked list, 트리
  * 하루는 이론+워크샵, 하루는 실습+워크샵.
  * 12, 13주차: 2주 내내 알고리즘.
  * 이후 응용 강의 후 IM 취득자는 AD, 미취득자는 IM 재시험

* Language

  * ALGOL - B - C
  * C: 데니스 리치, UNIX 운영체제 제작 위한 전문가용 언어.
  * C는 포인터가 있고 Java, C#, python은 포인터가 없음. 포인터가 어려움.
  * Java는 OOP 때문에 어렵다고.
  * C - Java
  * C - C++
  * Java의 처음 이름은 Oak. 썬 마이크로시스템즈(회사)에서 제작. 그린 프로젝트에서 시작. 당시엔 망했으나, 인터넷의 발달로 떠오름. 현재는 안드로이드도 java로 되어있지. 현재는 Oracle에 넘어와있음. Oracle은 데이터베이스 만드는 회사. MySQL도 Oracle에 넘어옴.
  * C++은 특정한 회사 소속이 아니라 MS 사에서 개발툴을 제공할 뿐. 다른 회사 개발툴도 있음. C++은 C를 포함하고 있음. 
  * Java, C++ - C#: MS에서 Java에 대항하기 위해 만듦. Java와 거의 비슷. C++ 요소 일부 포함.  회사 차원에서 매우 공들이는 중. 게임 프로그래밍에 많이 사용. 아직 java를 따라잡지는 못함.
  * VB(Visual Basic) - .NET으로 이름 바뀜. C#이 더 많이 쓰임.
  * Python: 귀도 반 로섬. 네덜란드 프로그래머 작. Interpreter 언어.
  * Interpreter: 한 줄씩 실행
    * Javascript, HTML / PHP, JSP, ASP
  * Compiler: 한 번에 실행. 속도가 더 빠름. 
    * 대부분의 언어는 Compile 언어. java는 interpreter 언어라고 하기도 함.

  * 프로그래밍: 요구사항 분석 - 설계 - 구현 - 디버깅 - 테스트 - 유지보수
    * 문제, 제약조건 파악. 요구사항을 제대로 분석해야.
    * 설계: 연필로 가장 작은 테스트케이스 해결
    * 코딩
    * 문제, 설계 단계가 중요하다는 소프트웨어 방법론. Language는 도구일 뿐.
    * 하고자 하는 분야(머신러닝, 빅데이터 등)에 python의 library가 잘 되어있어서 python을 쓰는 것뿐. 비전공자가 배우기도 편하고.
  * 하나의 언어를 잘 해놓으면 다른 언어도 금방 익힐 수 있다. 개념을 잘 알고 있으면, 어떻게 표현하는지만 파악하면 되니까. 그러니까 언어가 중요한 게 아니라 그 언어가 제공하는 library 등에 초점을 맞추는 것.

## 1. 배열 1 (Array 1)

### 1.1 알고리즘

유한한 단계를 통해 문제를 해결하기 위한 절차나 방법. 

* 대수학의 아버지, 페르시안 수학자 알콰리즈미의 이름에서 따옴.

* 알고리즘에선 식을 만들 수 있으면 유리하다. 공식이 제일 빠르니까.

* `슈더코드`와 `순서도`: 컴퓨터 분야에서 알고리즘을 표현하는 방법 두 가지. 설계할 때 사용.
* 슈더코드(pseudocode): 코드가 어떻게 돌아가는지 정도만 보여주는 코드. 중간코드.
* `UML diagram`: 객체지향 language 설계 툴.
* 좋은 알고리즘
  * 정확성
  * 작업량
  * 메모리 사용량
  * 단순성
  * 최적성
* 다양한 알고리즘으로 문제 해결 가능 - 알고리즘 성능 분석 필요
* `시간 복잡도(Time Complexity)`: 알고리즘의 작업량 표현. 실제 걸리는 시간 측정. 실행되는 명령문의 개수를 계산.
* 시간 복잡도 ~ `빅-오 표기법(Big-Oh Notation)`: 시간복잡도 함수 중 가장 큰 영향력을 주는 n에 대한 항을 계수 생략하여 표시.
  * 예) O(2n^2 + 10n + 100) = O(n^2), 상수 시간은 O(1)
  * n! > 2^n >  n^2 > nlogn > n > logn > 1
    * logn: 이진탐색. 예) 생각한 숫자 맞추기. 답변은 크다, 작다. - 한 번 진행할 때마다 반씩 버린다. 빠름.
    * n: 순차탐색. 예) 생각한 숫자 맞추기. 하나씩 다 물어본다.
    * nlogn: Quick sort, 병합 정렬, Heap sort.
      * 정렬
        * 선택(작은것부터 순서대로 or 큰것부터 순서대로), 버블(이웃비교), 삽입(책정리처럼 하나씩 사이에 꽂는 것) - O(n^2)
        * Quick sort, 병합 정렬, Heap sort - nlogn
        * Radix(기수), Shell 등
        * 10억 개의 데이터를 n^2 정렬하면 300년이 걸리지만, nlogn 정렬하면 5초면 된다.
    * n^2: 다이익스트라(최단 경로)
    * n^3: 프로이드의 최단 경로 알고리즘
    * 2^n: 부분집합
    * n!: 순열
    * P 문제 - ~n^3: 다항식 문제. 
    * NP 문제 - 2^n부터~: n이 커지면 시간 안에 나오지 않는다. 
      * 가지치기 필요.
      * 근사 알고리즘, 휴리스틱 이용. 

### 1.2 배열

```
* 파이참(PyCharm) 설치, Community Edition(open-source): 알고리즘 디버깅용. web 개발이나 db 연결은 안됨. 프로젝트 단위 관리. vs code는 파일만 있으면 됨.
* 디버깅 어원: 탄도 계산을 위해 만든 프로그램 외장 방식 컴퓨터 애니악(우리가 쓰는 내장 방식은 폰 노이만이 만듦.)에서 발생한 오류, 진공관에 들어간 나방을 잡은 것에서 왔다.
* 프로그램 작동 원리: 하드디스크(HDD)에 설치한 프로그램을 메모리(RAM)에 로드, CPU가 실행하여 RAM에 저장한 결과를 HDD에 저장한다.
* 32bit 운영체제는 램을 4GB까지밖에 인식하지 못한다.
* 파일 이름, 경로 등은 파이참 안에서 바꿀 것.
```

* 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조. (python은 자료형 달라도 됨.)
* 연속적인 영역을 index로 구분하여 사용. 메소드 없이 index로 접근하여 입력, 수정 가능.
* python에서 배열은 C, Java와는 달리 크기가 고정되어 있지 않아 편리.
* 변수를 하나 하나 따로 사용하는 것보다 훨씬 효율적. 선언, 작업 모두.

* 1차원 배열
  * 별도의 선언 방법이 없으면, 변수에 처음 값을 할당할 때 생성.
  * 1차원 배열의 접근: Arr[idx] = value
* 연습문제 1)  Gravity
  * m) 오른쪽의 빈칸만큼이 낙차. 그걸 셀 수 있으면 된다. 
  * t) 제일 높은 위치에 있는 상자의 낙차가 가장 크다. 내 아래에 있는(나보다 인덱스 번호가 큰) 상자탑의 높이가 나보다 크거나 같으면 최대 낙차에서  한 칸씩 빼준다. 인덱스마다 그걸 반복하여 max를 구하면 됨.
  * 이중 for문.
  * 만약 좌표로 준다면 칸마다 구해야 하지만, 이건 연결되어 있으므로 제일 윗 상자만 생각하면 된다. 좌표로 구할 경우 for문이 세 개 필요하지.
  * 문제 풀 땐 종이와 연필을 활용하자.
* 연습문제 2) Baby-gin Game
  * 0~9의 숫자 카드, 임의의 카드 6장 복원추출.
  * 3장의 카드 
    * 연속적인 번호: run
    * 동일한 번호: triplet
    * 6장이 run과 triplet으로만 이루어지면 baby-gin.
  * 6자리 숫자를 입력받아 baby-gin 여부를 판단하는 프로그램.
  * 미국의 정보올림피아드 문제. 
  * 한국정보올림피아드: 교재와 강좌를 사이트에서 볼 수 있음. 
  * m) 같은 숫자를 모아 triplet을 먼저 확인하고 중복카드 제거 후 run 확인하면 되지 않을까.
  * t) 제일 무식한 방법: 모든 경우의 수 확인 - 완전검색

### 1.3 완전검색 (Exaustive Search)

> 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법.
>
> Brute-force 혹은 generate-and-test 기법이라고도 불린다.
>
> 모든 경우의 수를 테스트하므로 안전하지만, 오래 걸리므로 경우의 수가 적을 때 유용하다.
>
> 자격검정평가 등에서 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직하다.

* 완전 검색을 활용한 Baby-gin 접근: 6개의 숫자 - 순열 - 모든 경우의 해답 테스트
  * m) baby-gin의 모든 경우의 수 집합을 만드는 줄 알았는데 아니네.

* 순열(Permutation)
  * 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것.
  * nPr = n * (n-1) * ... * (n-r+1)
  * nPn = n!

### 1.4 그리디 (Greedy Algorithm)

> 최적해를 구하는 데 사용되는 근시안적인 방법.
>
> 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
>
> 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다.
>
> 일반적으로, 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근이 된다. 

* 탐욕 알고리즘의 동작 과정
  * 1) 해 선택: 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해 집합(Solution Set)에 추가한다.
  * 2) 실행 가능성 검사: 새로운 부분해 집합이 실행 가능한지 확인 후 문제의 제약 조건을 위반하지 않는지 검사한다. 
  * 3) 해 검사: 새로운 부분해 집합이 문제의 해가 되는지 확인한다. 아직 전체 문제의 해가 완성되지 않았다면, 1)의 해 선택부터 다시 시작한다.
* 예) 거스름돈 줄이기: 지폐와 동전의 개수 최소화
  * 1) 해 선택: 단위가 가장 큰 동전 추가
  * 2) 실행 가능성 검사: 초과한다면 1로 돌아가 한 단계 작은 단위의 동전을 추가한다.
  * 3) 해 검사: 거스름돈을 확인해 모자라면 다시 1로 돌아가 추가할 동전을 고른다.
  * 그런데 이 경우, 만약 500원, 400원, 100원 동전이 있는 상황에서 800원을 만들려 하면 그리디 방법으로는 500원 하나, 100원 세 개가 되지만, 실제 답은 400원 두 개다. 즉, 그리디 방법은 상황에 따라 맞을 수도, 아닐 수도 있다.
* Baby-gin 접근: count 해놓고 run 또는 triplet 체크 후 이용한 데이터 삭제, 또 체크하면 결과를 알 수 있다.
  * 답안의 카운트 방법 특이하다. %, // 자주 쓰이니 알아둘 것.
  * python에선 str 이용 가능. 앞에 0 들어가는 경우 생각해 처리 주의.

```python
num = 456789
c = [0]*12 #반복문에서 i+1, i+2 돌리기 위해 두 칸 추가
for i in range(6):
    c[num%10] += 1
    num //= 10
# 아래 반복문에서 i += 1을 끝에 넣어 같은 i값으로 if에서 continue로 올라가게 한 이유: run이 둘, triplet이 둘일 수도 있기 때문에.
while i < 10:
    if : # triplet 조사 후 데이터 삭제
    	continue
    if : # run 조사 후 데이터 삭제
        continue
    i += 1
```

> **정렬**: 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순: ascending), 혹은 그 반대의 순서대로(내림차순: descending) 재배열하는 것
>
> 키: 자료를 정렬하는 기준이 되는 특정 값.
>
> 대표적인 정렬 방식: 버블(Bubble): O(n^2), 카운팅(Counting): O(n+k), 선택(Selection): O(n^2), 퀵(Quick): O(nlogn, n^2), 삽입(Insertion): O(n^2), 병합(Merge): O(nlogn)

### 1.5 버블 정렬 (Bubble Sort)

> 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식.
>
> 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블 정렬이라고 한다.
>
> 시간 복잡도: O(n^2)

```python
def BubbleSort(a):
    for i in range(len(a)-1, 0, -1):
        for j in range(0, i): # 제어 변수.
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]
```

* `call by value`: 복사 -작은 값. 
  * 예) 일반 변수 하나
* `call by reference`: 원본 참조 - 큰 값. 
  * 예) 리스트, 객체 
* RAM에 `code`, `data`, `heap`, `stack` 영역이 있다. 
  * `stack`에 함수들이 쌓인다.
    * swap(a, b)의 경우 main 함수 영역에서 swap 영역으로 값을 복사해서 넘긴다.
    * swap 영역에서 값을 변경해도 main의 값은 영향을 받지 않는다.
    * list, 객체는 heap에 만들어진다. main 영역은 그 주소를 가리키고, bubble 영역에 그 주소를 넘긴다.
    * 함수에서 값을 변경하면 원본도 변경된다. 원본 '참조'이기 때문에.
  * global 붙이면 data 영역으로 간다.

### 1.6 카운팅 정렬 (Counting Sort)

> 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간(1차원)에 정렬하는 효율적인 알고리즘.
>
> 제한사항: 정수 또는 정수로 표현할 수 있는 자료(예) 문자(아스키코드))에만 적용 가능. 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문. 카운트를 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다.
>
> 시간 복잡도: O(n+k): n은 리스트의 길이, k는 정수의 최대값
>
> 원본을 건드리지 않는다.

* 카운팅 정렬 과정
  * Data에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 counts에 저장한다.
  * 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를 조정한다. (누적)
    * 추후 자기 자리를 찾아갈 수 있도록. 카운트의 숫자는 최종 들어가야 할 자리의 인덱스 +1인 상태.
  * counts를 감소시키며 Data를  뒤에서부터 Temp에 삽입한다. 
  * mQ) 원본을 뒤에서부터 읽으면서 넣지 않아도 되지 않나? 
    * A) 맞다. 앞에서부터 읽으며 넣어도 괜찮다. 카운트가 누적이라는 것만 알면 됨.

### 1.7 실습

* View
  * m) 좌우 두 칸 체크. 나보다 키 큰 애가 없으면 조망권 확보, 카운트 증가. - 성공!
  * m) bubble sort 안 만들고  변수 하나로 비교해서 해도 되는데, 귀찮아서 그냥 sort 씀.
  * oth) max 함수를 만들어서 불러온 사람도 있네.
  * t) 뺀 값의 최소값이 0보다 크면 결과에 더하는 방식으로. 
    * 주의) min 값 초기화는 큰 값으로, max값 초기화는 작은 값으로. 혹은 배열의 첫 번째 값으로.

* Flatten

  * m) max, min 먼저 구해놓고 해서 복잡했는데

  * t) 구하는 것과 계산 한 번에 할 수 있다. idx로 접근해서 for문 한 번만 돌려서

  * mq) 중첩 for에서 빠져나가는 법

    * a) 함수 써서 return해야지 break로는 한 번밖에 못 빠져나간다.

    * 병석) 그 아래에 else: continue 다음 그 바깥에서 break하면 된다.

    * ```python
      else:
          continue
      break
      ```

  * 병석) 100층까지니까 cnt로 100칸 만들어놓고 해당 층의 건물 숫자를 카운트로 넣는 방법 사용. 

* 정리

  * min max

    * 배열의 첫 번째 값을 넣거나, min에는 아주 큰 수를, max에는 아주 작은 수를 넣고 시작.

  * 전기버스

    * 충전기 있는 정류장 리스트
    * last 충전소와 count 변수
    * data[i] - data[i-1] / data[i] - last 와 k 비교, 갈 수 있는 데까지 가고 충전.
    * 여기까지 못 오면 그 전에서 충전하는 식.
    * 함수 쓰면 느리지만, 모듈화가 가능.

  * 숫자카드

    * str로 받아서 int로 변환하여 0~9 idx를 갖는 c에서 카운트.
    * max와 idx를 구한다. '<=' 이용하여 같을 때도 idx가 더 큰 걸로 바뀌도록.

  * 구간합

    * range(N-M+1) > sum=0, range(M) > sum+=arr[i+j]
    * 2차원 합 구하기의 경우, 4개 중첩으로 확장.
    * 초기화 위치 중요

  * Flatten

    * 실행횟수만큼 max, min도 초기화 해줘야. 초기화 위치 중요.
    * 실행종료 후 min, max 다시 구해줘야.

    