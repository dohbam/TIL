# 그래프

* n대 n의 관계
* 1) 표현 방법
  * 인접행렬, 인접리스트, 간선의 배열 등
* 2) 순회
  * DFS, BFS
* v개 정점을 가지는 그래프는 최대 v*(v-1)/2개의 간선을 가질 수 있다.
* 그래프 유형
  * 무향 그래프
  * 유향 그래프
  * 가중치 그래프
  * 사이클 없는 방향 그래프
  * 사이클도 방향성도 없는 그래프 -> 트리
  * 완전 그래프: 가능한 모든 간선을 가진 그래프
  * 부분 그래프: 일부 정점이나 간선을 제외한 그래프

* 인접 정점
  * 인접: 두 정점 사이에 간선이 존재
  * 완전 그래프의 정점은 모두 인접
* 그래프 경로
  * 한 정점을 최대 한 번만 지나는 경로: 단순경로
  * 시작 정점에서 끝나는 경로: 사이클
* 그래프 표현
  * 간선 정보를 저장하는 방식
  * 인접 행렬: v*v 2차원 배열 이용. 포인터 배열
  * 인접 리스트: 각 정점마다 간선 정보 저장
  * 간선의 배열: 간선을 배열에 저장
* 인접 행렬
  * 두 정점을 연결하는 간선 유무를 행렬로 표현
  * 무향 그래프: i행의 합 == i열의 합 == Vi의 차수
  * 유향 그래프: i행의 합 == Vi의 진출차수, i열의 합 == Vi의 진입차수
* 인접 리스트
  * 각 정점에 대한 인접 정점들을 순차적으로 표현
  * 연결 리스트
    * [[1, 3, 2, 1] ... ] - 0번에서 1번으로 가는 가중치 3, 2번으로 가는 가중치 1 

## 그래프 탐색

### DFS(깊이우선탐색)

* 후입선출구조 스택 사용
* 스택의 구현
  * 선형으로 저장할 저장소
  * push, pop, isEmpty, peek

### BFS(너비우선탐색)

* 선입선출구조 큐 사용
  * python 시간: queue 라이브러리 > pop(0) > C처럼 front, rear로 구현한 큐
  * C처럼 큐를 구현할 때, 큐가 터지지 않도록 충분히 크게 만든다.
  * front, rear = -1, -1
  * enQ
    * rear += 1, Q[rear] = item
  * deQ
    * front += 1, item = Q[front]
  * empty
    * rear == front
* enQ 시 visted check, 하고자 하는 작업 수행

## 서로소 집합들 (Disjoint-Sets)

* KRUSKAL 알고리즘으로 사이클 유무를 판단할 때 사용
  * 사이클이 있으면 트리가 아니니까 MST 사용 불가
* 서로소 또는 상호베타 집합: 서로 중복 포함된 원소가 없는 집합
* 집합에 속한 하나의 특정 멤버(대표자)를 통해 각 집합 구분
* 연결 리스트 또는 트리로 표현한다.
* 연산
  * Make-Set(x), Find-Set(x), Union(x, y)
* 상호 배타 집합 표현 - 연결 리스트
  * 같은 집합 원소들은 하나의 연결 리스트로 관리
  * 맨 앞 원소: 집합의 대표 원소
  * 각 원소는 집합의 대표원소를 가리키는 링크를 갖는다.
* 상호 배타 집합 표현 - 트리
  * 하나의 집을 하나의 트리로 표현
  * 자식노드가 부모노드를 가리키며 루트노드가 대표자가 된다.
  * 자기 자신을 가리키는 노드가 대표자
  * 구현 예)
    * [0, 1, 2, 3, 4, 5]
    * Union(2, 3) -> [0, 1, 2, 2, 4, 5]
    * Union(4, 5) -> [0, 1, 2, 2, 4, 4]
    * Union(2, 4) -> [0, 1, 2, 2, 2, 4]
      * Union(3, 5) -> Union(2, 4) (대표자를 찾아서 연결)
    * find-set(5) -> 4->2->2: 2
    * make-set(6) -> [0, 1, 2, 2, 2, 4, 6]
* 문제점
  * 대표자를 찾고 리턴하는 많은 과정
  * 개선방법1:
    * path compression: Find-set을 행하는 과정에서 만나는 모든 노드들이 직접 root를 가리키도록 포인터를 바꾸어준다.
  * 개선방법2:
    * Rank를 이용한 Union
      * 자신을 루트로 하는 subtree의 높이를 rank로 저장.
      * Union 할 때 rank가 낮은 집합을 rank가 높은 집합에 붙인다.
      * 같을 경우 Union은 랭크가 하나 증가
      * -> path compression으로 높이 줄이기

## 최소신장트리(MST)

* 그래프에서 최소 비용 문제
  * 모든 정점을 연결하는 간선들의 가중치의 합이 최소가 되는 트리
  * 두 정점 사이의 최소 비용 경로 찾기
  * 예) 송유관 깔기
* 신장 트리
  * n개의 정점으로 이루어진 무향 그래프 중 n개의 정점과 n-1개의 간선으로 이루어진 트리
* 최소신장트리
  * 무향가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치의 합이 최소인 신장트리
* 예) A-B-C-D-A (가중치: 1, 2, 3, 4)
  * 신장 트리: A-B-C-D, B-C-D-A, C-D-A-B, D-A-B-C
  * 최소신장트리: A-B-C-D: 가중치 1+2+3
* MST 표현
  * 인접행렬, 인접리스트(링크드리스트), 간선의 배열, 트리 등
* PRIM 알고리즘
  * 하나의 정점에서 연결된 간선들 중 하나씩 선택하며 MST를 만들어가는 방식
    * 임의 정점을 하나 선택해서 시작
    * (지금까지 선택한 모든 정점 중) 최소 비용의 간선이 존재하는 (아직 선택하지 않은) 정점을 선택
    * 모든 정점이 선택될 때까지 반복
  * 서로소인 2개의 집합(2 disjoint-sets) 정보를 유지
    * 트리 정점들 - MST를 만들기 위해 선택된 정점들
    * 비트리 정점들 - 선택되지 않은 정점들
  * 알고리즘
    * key(가중치) -> 무한대, p(부모) -> 자기자신
    * 시작정점의 가중치 <- 0
    * 우선순위Q <- 모든 정점
    * while Q
      * (방문 안 한 정점 중) key가 가장 작은 정점 가져오기
      * 그 정점의 인접 정점들 중
      * Q에 있는(아직 방문 안 한) v의 부모(u), key값 갱신 - 더 작은 걸로
  * 그리디 알고리즘. PRIM이 증명했으니 써도 됨.
  * O(n^2)
* KRUSKAL 알고리즘
  * 간선을 하나씩 선택해 MST를 찾는 알고리즘
    * 최초, 모든 간선을 가중치에 따라 오름차순으로 정렬
    * 가중치가 가장 낮은 간선부터 선택하면서 트리 증가
      * 사이클이 존재하면 다음으로 가중치가 낮은 간선 선택
    * n-1 개 간선이 될 때까지 반복
  * 알고리즘
    * 모든 정점 make_set
    * 간선들을 가중치 w 기준 정렬
    * 가중치가 가장 낮은 간선 중 두 정점의 find_set이 일치하지 않는 간선 선택
    * 두 정점 union
  * O(mlogm) m: 간선의 개수

## 최단경로

* 간선의 가중치가 있는 그래프에서 두 정점 사이의 경로들 중 간선의 가중치의 합이 최소인 경로
* 하나의 시작 정점에서 끝 정점까지의 최단 경로
  * 다익스트라 알고리즘
    * 음의 가중치 허용하지 않음
    * O(n^2)
  * 벨만-포드 알고리즘
    * 음의 가중치 허용
* 모든 정점들에 대한 최단 경로
  * 플로이드-워샬 알고리즘: O(n^3) : 알고리즘이 다익스트라보다 간단
  * 다익스트라 n-1번 반복 -> O(n^3)
* Dijkstra 알고리즘
  * 시작 정점에서 거리가 최소인 정점을 선택해 나가며 최단 경로를 구함
  * s - (최단경로) - x - (최단경로) - t
  * 그리디 알고리즘. MST의 프림 알고리즘과 유사.
  * 알고리즘
    * A: 인접행렬(자기자신은 0, 길 없는 곳은 무한대), V: 정점집합, U: 선택된 정점집합
    * U <- 시작정점 s
    * 모든 정점에 대해 D[v] = A[s\][v]
    * while U != V
      * D[w]가 최소인 (아직 선택하지 않은) 정점 w  선택
      * U <- w
      * w 에 인접한 (아직 선택하지 않은) 모든 정점 v
        * D[v] = min(D[v], D[w]+A[w\][v])
    * -> 경로는 보이지 않음. 값만 보임.
* 플로이드-워샬 알고리즘 (강의자료 DP2: 응용2 p.234)
  * O(n^3), 다익스트라 알고리즘 (n-1)번 사용하는 것과 같지만, 알고리즘이 매우 간단하여 보다 효율적이다.
  * DP 접근방법
    * 부분문제 찾기
      * 점이 3개인 경우, 경유하는 경로와 직접 가는 경로 중 짧은 것을 선택하면 된다.
    * 점 하나씩 추가
    * 1~n까지의 모든 점을 경유 가능한 점들로 고려하며 모든 쌍의 최단 경로의 거리 계산
    * 주의) 모든 점을 반드시 경유하는 경로 아님
    * k != i, k != j, k=0: 점 0 없음. :어떤 점도 경유하지 않는다는 의미.
      * Dij0은 입력으로 주어지는 선분ij의 가중치
    * 모든 쌍 i와 j에 대하여 Dij1을 계산하는 것이 가장 작은 부분 문제들. (i!=1, j!=1)
    * 그 다음엔 i에서 점 2를 경유하여 j로 가는 경로와 Dij1 중 짧은 거리를 Dij2로 정함.
      * 점2를 경유하는 경로의 거리는 Di21 + D2j1
    * 모든 쌍 i와 j에 대하여 Dij2 계산. (i!=2, j!=2)
    * ...
    * 점 i에서 점 k를 경유하여 점 j로 가는 경로의 거리와 Dij(k-1)중 짧은 것.
      * Dik(k-1)+Dkj(k-1) (i!=k, j!=k)
    * 이런 방식으로 k가 1에서 n이 될 때까지 Dijk를 계산하여 Dijn을 찾는다.
  * 알고리즘
    * D[i\][j] = 선분ij의 가중치
    * for k in 1->n
      * for i in 1->n (i != k)
        * for j in 1->n (j!=k, j!=i)
          * D[i\][j] <- min(D[i\][k]+D[k\][j], D[i\][j])

