# 8. Tree

* 그래프와 트리
  * 그래프
    * 정점과 간선으로 이루어짐
    * 표현방법: 인접행렬 / 인접정점의 리스트 / 간선의 배열
    * 순회: DFS / BFS
    * 방향성, 가중치가 있을 수 있다.
  * 트리
    * 그래프의 부분집합
    * 사이클(a->b->c->a)이 없는 그래프
    * -> 계층관계 有, 방향성 無
  * 이진트리 탐색 방법 (DFS나 BFS보다 효율적, 용이)
    * 1) preorder
    * 2) inorder
    * 3) postorder
* 트리의 개념
  * 비선형 구조
  * 1:n 관계
  * 계층관계, 계층형 자료구조
  * 상위 원소에서 하위 원소로 내려가면서 확장되는 트리(나무)모양의 구조
* 트리의 정의
  * 한 개 이상의 노드로 이루어진 유한 집합이며 다음 조건을 만족한다.
    * 1) 노드 중 최상위 노드를 루트(root)라 한다.
    * 2) 나머지 노드들은 n(n>=0)개의 분리집합 T1, ... , TN으로 분리할 수 있다.
    * 이 때, T1, ... , TN은 각각 하나의 트리가 되며(**재귀적 정의**) 루트의 부 트리(subtree)라 한다.
    * 자식이 없는 노드: 단말노드, 잎 노드, leaf 노드. (<-> 가지노드)
* 용어 정리
  * 노드(node) - 트리의 원소
  * 간선(edge) - 노드를 연결하는 선. 부모 노드와 자식 노드를 연결
  * 루트 노드(root node) - 트리의 시작 노드
  * 형제 노드(sibling node) - 같은 부모 노드의 자식 노드들
  * 조상 노드 - 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
  * 서브 트리(subtree) - 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
  * 자손 노드 - 서브 트리에 있는 하위 레벨의 노드들
  * 차수(degree)
    * 노드의 차수: 노드에 연결된 자식 노드의 수
    * 트리의 차수: 트리에 있는 노드의 차수 중 가장 큰 값
    * 단말 노드(리프 노드): 차수가 0인 노드, 자식 노드가 없는 노드
  * 높이
    * 노드의 높이: 루트에서 노드에 이르는 간선의 수. 노드의 레벨.
    * 트리의 높이: 트리에 있는 노드의 높이 중 가장 큰 값. 최대레벨.
* 이진트리
  * 모든 노드들이 2개의 서브트리를 갖는 특별한 형태의 트리
  * 각 노드가 자식 노드를 최대한 2개까지만 가질 수 있다.
    * 왼쪽 자식 노드(left child node)
    * 오른쪽 자식 노드(right child node)
* 이진트리 특성
  * 레벨 i에서 노드의 최대 개수는 2^i개
  * 높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 h+1 개, 최대 개수는 2^(h+1)-1 개
* 이진트리의 종류
  * 포화 이진 트리 (Full Binary Tree)
  * 완전 이진 트리 (Complete Binary Tree)
    * 포화 이진 트리의 노드번호 1번부터 n번까지 빈 자리가 없는 이진 트리
  * 편향 이진 트리 (Skewed Binary Tree)
    * 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리

### * 이진트리 - 순회(traversal)

* 순회: 트리의 각 노드를 중복되지 않게 전부 방문하는 것.
* 전위순회(preoreder traversal): VLR
  * 부모 노드 방문 후, 자식 노드를 좌, 우 순서로 방문한다.
  * -> 재귀, DFS
* 중위순회(inorder traversal): LVR
  * 왼쪽 자식 노드, 부모 노드, 오른쪽 자식 노드 순으로 방문한다.
* 후위순회(postorder traversal): LRV
  * 자식 노드를 좌우 순서로 방문한 후, 부모노드로 방문한다.
* 이진트리의 경우, cycle이 없으므로 방문체크 불필요.
* p.402 연습 -> 정답!
  * 전위: A-B-D-H-I-E-J-C-F-K-G-L-M
  * 중위: H-D-I-B-J-E-A-F-K-C-L-G-M
  * 후위: H-I-D-J-E-B-K-F-L-M-G-C-A

### 이진트리의 표현

* 배열을 이용한 이진트리의 표현

  * 각 노드 번호 부여 (루트=1) -> 배열의 인덱스로 활용
  * 노드 번호의 성질
    * 노드 번호가 i인 노드의 부모 노드 번호: i//2
    * 노드 번호가 i인 노드의 왼쪽 자식 노드 번호: 2*i
    * 노드 번호가 i인 노드의 오른쪽 자식 노드 번호: 2*i+1
    * 레벨 n인 노드의 시작 번호: 2^n
  * 높이가 h인 이진트리를 위한 배열의 크기:
    * 레벨 i의 최대 노드 수: 2^i
    * 따라서 (시그마)2^i = 2^(h+1)-1
    * h를 모르면, 알아서 크게 잡아야지.
  * 단점
    * 편향 이진 트리의 경우 메모리 공간 낭비 발생
    * 트리의 중간에 새로운 노드를 삽입하거나 기존의 노드를 삭제할 경우 배열의 크기 변경이 어려워 비효율적

* 연결리스트를 이용한 트리의 표현

  * 연결리스트
    * 논리적으로는 연결되어 있지만, 실제로는 아니므로 공간 낭비 없고 삽입, 삭제 효율적.
    * 단점: 구현이 어렵다. (1차원 배열) -> 2차원 배열로 구현할 수 있다.
  * 구조: 왼쪽자식노드링크 | 데이터 | 오른쪽자식노드링크

* 연습문제

  * tree: 정점 V개, 간선 V-1개

  * code (2차원배열로 표현, left|right|parent)

    ```python
    def frontorder(node):
        if node != 0:
            print("{}".format(node), end=" ")
            frontorder(g[node][0])
            frontorder(g[node][1])
    def inorder(node):
        if node != 0:
            inorder(g[node][0])
            print("{}".format(node), end=" ")
            inorder(g[node][1])
    def postorder(node):
        if node != 0:
            postorder(g[node][0])
            postorder(g[node][1])
            print("{}".format(node), end=" ")
    ```

* 수식트리
  * 수식을 표현하는 이진 트리
  * 수식 이진 트리 (Expression Binary Tree)
  * 연산자는 루트 노드이거나 가지 노드
  * 피연산자는 모두 잎 노드
  * 수식트리의 순회
    * 중위 순회: 중위 표기법 식
    * 후위 순회: 후위 표기법 식
    * 전위 순회: 전위 표기법 식

### 이진탐색트리

* 이진탐색트리 (BST, Binary Search Tree)
  * 제약조건: 모든 원소는 서로 다른 유일한 키를 갖는다.
  * key(왼쪽 서브트리) < key(루트 노드) < key(오른쪽 서브트리)
  * 왼쪽 서브트리와 오른쪽 서브트리도 이진 탐색 트리다.
  * 중위 순회하면 오름차순으로 정렬된 값을 얻을 수 있다.
  * 탐색 연산
    * 루트에서 시작
    * 탐색할 키 값을 루트 노드의 키와 비교
      * x = 루트노드의 키값: 탐색 성공!
      * x < 루트노드의 키값: 루트노드의 왼쪽 서브트리에서 탐색연산
      * x > 루트노드의 키값: 루트노드의 오른쪽 서브트리에서 탐색연산
    * 서브트리에 대해 순환적으로 탐색 연산 반복
  * 삽입연산
    * 먼저 탐색연산을 수행
    * 탐색 실패한 위치에 원소 삽입
  * 성능
    * 탐색(searching), 삽입(insertion), 삭제(deletion) 시간: 트리의 높이
      * O(h), h: BST의 깊이(height)
    * 평균 (균형적 이진트리) - O(log n)
    * 최악 (경사 이진트리) - O(n): 순차탐색과 시간복잡도가 같다.
    * 검색 알고리즘 비교
      * 배열에서 순차 검색: O(n)
      * 정렬된 배열에서 순차 검색: O(n)
      * 정렬된 배열에서 이진 탐색: O(logn)
        * 삽입, 삭제 시 추가 연산 필요
      * 이진 탐색 트리 평균: O(logn)
        * 최악: O(n)
        * 완전이진트리 또는 균형트리로 바꿀 수 있다면 최악의 경우 제거 가능
      * 해쉬 검색: O(1)
        * 추가 저장 공간 필요: 충돌 안 나도록 잘 만드는 게 핵심
  * 삭제 연산
    * 잎 / 가지 / 루트 각각 구현
  * 연습문제 Tree - 이진탐색트리 만들기: inorder로 채우면 됨(1차원으로)

### 힙 (heap)

* 완전 이진 트리에 있는 노드 중에서 키값이 가장 큰 노드나 키값이 가장 작은 노드를 찾기 위해 만든 자료 구조
  * 우선순위 큐 구현 가능
* 최대 힙(max heap)
  * 키값이 가장 큰 노드를 찾기 위한 **완전 이진 트리**
  * 부모 노드의 키값 > 자식 노드의 키값
  * 루트 노드: 키값이 가장 큰 노드
* 최소 힙(min heap)
  * 키값이 가장 작은 노드를 찾기 위한 **완전 이진 트리**
  * 부모 노드의 키값 < 자식 노드의 키값
  * 루트 노드: 키값이 가장 작은 노드
* 힙 연산 - 삽입
  * 1) 완전이진트리 유지되도록 삽입할 자리 확장
  * 2) 부모가 자식 사이의 룰이 유지될 때까지 부모-삽입노드 간 자리 바꾸기 

* 힙 연산 - 삭제
  * 힙에서는 루트 노드의 원소만을 삭제할 수 있다.
  * 루트 노드의 원소를 삭제하여 반환한다.
  * 힙의 종류에 따라 최대값 또는 최소값을 구할 수 있다.
  * 예
    * 루트 노드의 원소 삭제
    * 마지막 노드 삭제 -> 값은 루트 노드로
    * 부모 자식 관계가 유지될 때까지 자리 바꾸기
    * -> 끝까지 삭제 과정 반복하면 힙 정렬. O(nlogn)