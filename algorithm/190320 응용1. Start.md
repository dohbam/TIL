# SW문제해결 응용

> 1. start
> 2. 완전검색
> 3. graph

## 1. Start

### 1) SW 문제 해결

* 설계 단계의 중요성
* 프로그램 구현 전, 요구사항을 철저하게 분석하여 문제를 정확하게 인지하고 해결할 수 있는 명확한 계획을 설계해야 한다.

### 2) 복잡도 분석

* 알고리즘: 문제 해결을 위한 절차나 방법
* 알고리즘의 효율
  * 공간적 효율성: 적은 메모리
  * 시간적 효율성: 적은 시간
  * 복잡도가 높을 수록 효율성 저하
* 시간복잡도 분석
  * 하드웨어, 소프트웨어 환경에 따라 처리 시간이 달라져 분석이 어려움.
* 복잡도의 점근적 표기
  * 시간(또는 공간) 복잡도는 입력 크기에 대한 함수로 표기하는데, 이 함수는 주로 여러 개의 항을 가지는 다항식이다.
  * 이를 단순한 함수로 표현하기 위해 점근적 표기(Asymptotic Notation)를 사용한다.
  * 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법이다.
  * O(Big-Oh)
    * 점근적 상한
    * 단순히 "실행시간이 ()에 비례"하는 알고리즘이라고 말한다.
    * n이 증가함에 따라 O(g(n))이 점근적 상한이라는 것을 보여준다.
    * 즉, g(n)이 n0보다 큰 모든 n에 대해 항상 f(n)보다 크다는 것.
  * (Big-Omega)
    * 점근적 하한
    * O-표기와 마찬가지로 복잡도 다항식의 최고차항만 계수 없이 취한다.
    * "최소한 이만한 시간은 걸린다."
    * n이 증가함에 따라 (g(n))이 점근적 하한이라는 것을 보여준다.
    * 즉, g(n)이 n0보다 큰 모든 n에 대해 항상 f(n)보다 작다는 것.
  * (Theta)
    * O-표기와 오메가-표기가 같은 경우에 사용한다.
    * "f(n)은 n이 증가함에 따라 g(n)과 동일한 증가율을 가진다."
* 자주 사용하는 O-표기
  * O(1): 상수 시간(Constant time)
  * P 문제
    * O(logn): 로그(대수) 시간(Logarithmic time): 이진탐색
    * O(n): 선형 시간(Linear time): 순차
    * O(nlogn): 로그 선형 시간(Log-linear time): Quick, Merge, Heap Sort
    * O(n^2): 제곱 시간(Quadratic time): 선택, 버블, 삽입 정렬. 다익스트라 최단경로.
    * O(n^3): 세제곱 시간(Cubic time): 연쇄행렬곱, 모든쌍 최단경로(Floyd).
  * NP 문제 - 근사 알고리즘(최적해*(1.5~2) 효율) 사용
    * O(2^n): 지수 시간(Exponential time): 부분집합, 조합
    * O(n^n): 순열, TSP
* 이 알고리즘으로 풀면 시간 안에 나오겠느냐? 를 알 수 있어야.
* 효율적인 알고리즘의 중요성.

### 3) 표준 입출력 방법

* 파일 입출력

  ```python
  import sys
  sys.stdin = open("input.txt", "r")
  sys.stdout = open("output.txt", "r")
  
  text = input()
  print(text)
  ```

* string으로 들어오므로, 원한다면 숫자로 변환

### 4) 비트 연산

* 피연산자가 정수일 때만 사용 가능

* 피연산자를 2진수로 변환하여 연산 후 10진수로 반환한다.

  | 연산자 | 기능                                      |
  | ------ | ----------------------------------------- |
  | &      | 비트 단위로 AND 연산                      |
  | \|     | 비트 단위로 OR 연산                       |
  | ^      | 비트 단위로 XOR 연산 (같으면 0, 다르면 1) |
  | ~      | 단항 연산자, 피연산자의 모든 비트 반전    |
  | <<     | 피연산자의 비트 열을 왼쪽으로 이동        |
  | >>     | 피연산자의 비트 열을 오른쪽으로 이동      |

* 1 << n

  * 2^n
  * 원소가 n개일 경우 모든 부분집합의 수
  * Power set(모든 부분집합): 공집합과 자기자신을 포함

* i & (1<<j)

  * 계산 결과는 i의 j번째 비트가 1인지 아닌지 의미
  * 부분집합 만들 때 사용했음

* 사용 예)

  * C클래스 ip 주소에서 앞의 세 자리는 라우터, 뒤 한 자리가 호스트
  * 255 255 255 0 과 & 연산하면 앞의 세 자리가 나온다.
  * 한 라우터는 0, 255 제외 254개 호스트를 가질 수 있는데
  * 라우터를 찾고자 할 때 위의 & 연산을 사용할 수 있다.

* 연습문제1

  * 2진수 1차배열을 7개씩 잘라서 10진수 변환하기
  * n = n*2 + int(s[j])

* 엔디안(Endianness)

  * 컴퓨터의 메모리와 같은 1차원 공간에 여러 개의 연속된 대상을 배열하는 방법
  * HW 아키텍처마다 다르다.
  * 빅 엔디안: 큰 단위가 앞에. 네트워크.
  * 리틀 엔디안: 작은 단위가 앞에. 대다수 데스크탑 컴퓨터.
  * 속도 향상을 위해 바이트와 워드를 변환하여 연산할 때 올바로 이해하지 않으면 오류가 발생할 수 있다.

### 5) 진수

* 10진수 -> 타 진수 변환
  * 원하는 타 진법의 수로 나눈 뒤, 나머지를 거꾸로 읽는다.
  * 소수점 아래 숫자는 원하는 타 진법의 수를 곱해서 정수만 읽는다.
    * 딱 떨어지게 나오지 않을 수 있다. 실수 연산은 엉뚱한 결과가 나올 수도 있음.
    * 컴퓨터에게 0.03+0.06+0.01을 시키면, 결과가 0.1과 같지 않다고 나온다.
    * 2진수로 바뀌지 않는 수가 있으니 정확한 연산을 원할 땐 데이터타입 직접 만들어서 사용해야.......
* 음의 정수 표현법
  * 2의 보수
    * 장점: 바로 계산 가능, 0, -0 중복되지 않음.
    * 부호 비트를 제외한 절대값 부분의 비트들을 변환 후 최하위 비트에 1을 더한다. 
  * 보통 int는 4byte, -2^31 ~ 2^31 -1 의 숫자 표현 가능
  * 파이썬은 big integer를 쓴다.
* 연습문제2
  * 16진수 배열 - 7bit씩 묶어 십진수 변환 출력

### 6) 실수

* 컴퓨터는 부동 소수점(floating-point) 표기법을 사용하여 실수를 표현한다.
* 소수점 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정하고 밑수의 지수승으로 표현한다.
  * 1001.0011 -> 1.0010011 x 2^3
* 고정 소수점 표기법을 사용할 경우, 아주 작은 수를 표현하기 어려움.
* 실수를 저장하기 위한 형식
  * 단정도 실수(32비트)
    * 부호 1비트 + 지수 8비트 + 가수 23비트
  * 배정도 실수(62비트)
    * 부호 1비트 + 지수 11비트 + 가수 52비트
  * 단정도 실수의 지수 부분을 만드는 방법
    * 8비트(256개 상태)를 익세스 표현법을 사용하여 음수지수와 양수지수 표현
    * 127이 0
    * -127 ~ 128까지의 값 표현
* 컴퓨터는 실수를 근사적으로 표현한다. (이진수로 표현할 수 없는 형태의 실수)
  * 이때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져온다. **주의**
* 실수 자료형의 유효 자릿수
  * 32비트 실수형 유효자릿수: 6자리 (10진수)
  * 62비트 실수형 유효자릿수: 15자리 (10진수)
  * 유효 자릿수를 넘어가면 엉뚱한 숫자가 저장된다.
* 파이썬에서의 실수 표현 범위
  * 최대값 약 1.8*10^308, 이 이상은 inf로 표현
  * 최소값 약 5.0*10^-324, 이 이하는 0으로 표현

* 연습문제 3
  * 16진수 1차 배열 -> 암호비트 패턴을 찾아 차례로 출력
  * 암호는 연속되어있다. -> 첫 번째 암호만 찾으면 그 뒤로 쭉 읽으면 됨.