# 3. 문자열(string)

```
(small talk)
* 무어의법칙을 반박하는 황의 법칙: 메모리반도체의 집적도는 1년에 두 배씩 늘어난다.
* python에는 str만 있지만, 문자: character, 문자열: string.
* XT(16bit) - AT - 386 - 486 - 586 - ...
* 한글 프로그램이 처음 만들어졌을 때 - 문자를 그려서 표현하는 거라 인코딩 없어도 출력, 작성 등 가능.
* 32bit 운영체제 - RAM 4GB 까지만 인식
* 64bit 운영체제 - 32bit 프로그램도 돌릴 수 있다. 
```

* 컴퓨터에서의 문자 표현
  * 각 문자마다 대응되는 숫자를 정해 메모리에 저장.
  * 영어는 대소문자 52자이므로 6비트(64가지 표현 가능)로 모두 표현할 수 있다. 이를 코드체계라고 한다.
  * 네트워크 발전으로 지역별 코드체계가 달라 정보 해석 문제 발생.
  * 1967년, 미국에서 ASCII라는 문자 인코딩 표준 제정.
    * ASCII(American Standard Code for Information Interchange)
    * 7bit 인코딩으로 128문자 표현. 
    * 33개의 출력 불가능한 제어 문자와 
      * \t, \n, \a 등
      * \0: NULL, ASCII 코드 0번
    * 공백을 비롯한 95개의 출력 가능한 문자로 이루어짐.
      * A: ASCII 코드 65번
      * a: ASCII 코드 97번
      * 사이에 다른 문자가 있으니 주의할 것.
    * 1byte: 영문자 한 자를 담을 수 있는 단위.
      * ASCII(7bit) + Parity(오류검사 1bit)
      * 오류 검사: 1의 개수가 짝수인지 홀수인지 넣어줌 
    * 확장 아스키: 표준 문자 + 악센트, 도형, 특수 문자, 특수기호: 8bit 모두 사용. 표준 아님.
  * 각 국가별로 자국의 문자를 표현하기 위해 코드체계 만들어 사용
    * 우리나라도 조합형, 완성형 두 종류의 한글 코드체계를 만들어서 사용했음.
  * 인터넷이 전 세계로 발전하며 국가간 정보를 주고받을 때 문제 발생.
  * 다국어 처리 표준 마련. "유니코드"
  * 유니코드
    * 2byte. ASCII 코드 포함 전 세계 문자 모두 표현 가능. 완성형 코드. 
    * 한글 만천여 자가 들어가 있음. 전체 6만여 자 중. 중국어 2만여 자.
    * 다시 Character Set으로 분류
    * UCS-2(Universal Character Set 2)
    * UCS-4(Universal Character Set 4)
    * 유니코드를 저장하는 변수의 크기를 정의. 바이트 순서 표준화하지 못함.
    * 파일 인식 시 UCS-2, UCS-4 인식 후 구분하여 다르게 구현해야 함.
    * 외부 인코딩 필요.
  * big-endian, little-endian
    * 16진수 네 자리(2진수 16자리, 1byte) 저장
      * 단위가 큰 것부터 12 34 저장: big-endian - server, network 등
      * 단위가 작은 것부터 34 12 저장: little-endian - 보통 desktop
      * 기종마다 다르게 저장.
  * 유니코드 인코딩 (UTF: Unicode Transformation Format)
    * UTF-8 (in web, python)
      * MIN: 8bit, MAX: 32bit(1Byte*4)
    * UTF-16(in windows, java)
      * MIN: 16bit, MAX: 32bit(2Byte*2)
      * 예) 한글 - "euc-kr"
    * UTF-32(in unix)
      * MIN: 32bit, MAX:32bit(4Byte*1)
  * Python 인코딩
    * 2.x 버전: ASCII: 첫 줄에 utf-8 명시해줘야 한글 표현 가능
    * 3.x 버전: 유니코드 UTF-8: 생략 가능
    * 다른 인코딩 방식으로 처리시 첫줄에 원하는 인코딩 방식 지정해주면 됨
      * 예) #-*- coding: utf-8 -*- 

### 3.1문자열

* 문자열(string)
  * fixed length
  * variable length
    * length controlled: java
    * delimited: c

* java의 string 클래스
  * 객체 메타 데이터 + hash + count + offset + value
* C언어의 문자열 처리
  * 문자들의 배열 형태로 구현된 응용 자료형
  * 문자배열에 문자열을 저장할 때에는 항상 마지막에 끝을 표시하는 널문자('\0', ASCII Code 0번)를 넣어줘야 한다.
  * 문자열 처리에 필요한 연산을 함수 형태로 제공한다.
    * strlen(), strcpy(), strcmp() 등
  * (문자가 숫자에 가깝다. 더하기 연산시 아스키코드값을 더해 나오는 등.)
* Java(객체지향 언어)에서의 문자열 처리
  * 문자열 데이터를 저장, 처리해주는 클래스 제공
  * String클래스 사용
  * 문자열 처리에 필요한 연산을 연산자, 메소드 형태로 제공한다.
    * +, length(), replace(), split(), substring()
    * 보다 풍부한 연산 제공
* Python에서의 문자열 처리
  * char 타입 없음
  * 텍스트 데이터의 취급방법이 통일되어 있음
  * 문자열 기호
    * ', ", ''', """
    * '+' 연결(Concatenation)
    * '*' 반복
  * 문자열은 시퀀스 자료형으로 분류, 시퀀스 자료형에서 사용할 수 있는 인덱싱, 슬라이싱 연산 사용 가능.
  * 문자열 클래스에서 제공되는 메소드
    * replace(), split(), isalpha(), find()
  * 문자열은 튜플과 같이 요소값을 변경할 수 없다. (immutable)
* C, Java, Python String 처리의 기본적인 차이점
  * C는 아스키 코드로 저장
    * "홍길동": 6글자
  * java는 유니코드(UTF16, 2byte)로 저장
    * "홍길동": 3글자
  * Python은 유니코드(UTF8)로 저장
    * "홍길동": 3글자
* 문자열 뒤집기
  * 자기 문자열에서 뒤집는 방법
    * 임시 변수 필요. 반복수행 문자열 길이의 반만큼.
  * 새로운 빈 문자열을 만들어 소스의 뒤에서부터 읽어서 타겟에 쓰는 방법
* 연습문제1
  * c: 알고리즘대로
  * java: StringBuffer 클래스의 reverse() 메소드 이용.
  * Python: Reverse 함수 혹은 slice notation 이용.
    * s[::-1] == s[-1:0:-1]
* 문자열 비교
  * c: 절차지향. 함수 제공
    * (*: pointer 의미)
  * java: 객체 지향. equals() 메소드 제공.
    * == 연산은 메모리 참조가 같은지 묻는 것.
    * (java는 pointer가 없어서 class(reference) 이용하여 주소 넘김.)
    * (java virtual machine이 garbage collection 별도로 해줌. 요즘 좀 빨라짐.)
  * python: 객체 지향. == 연산자와 is 연산자 제공.
    * == 연산자는 내부적으로 특수메소드 \_\_eq\__()를 호출. 연산자 중복정의(overide).
    * c처럼 짜본 strcmp(str1, str2)
      * 1) 길이 비교
      * 2) str indexing을 이용해 하나씩 비교
      * 다를 때 False를 return하는 함수
* 문자열 숫자를 정수로 변환하기
  * c: atoi() 함수 제공. 역함수는 itoa()
    * array to integer, integer to array
  * java: 숫자 클래스의 parse 메소드 제공.
    * (parsing: 자를 수 없을 때까지 자르는 것.)
    * (더는 자를 수 없는 것: token.)
    * Integer.parseInt(String)
    * 역함수 toString() 메소드.
  * python: 숫자와 문자 변환 함수 제공.
    * int('123'), float('3.14'), str(123), repr(123)
  * atoi()
    * value = (value * 10) + digit;
* 문자열 교체하기
  * c: 뒷부분을 잘라서 보관해놓고 원하는 부분을 교체하고 뒷부분에 넣어주기.
  * python: replace() 메소드 사용.

### 3.2 패턴 매칭

#### 1) 고지식한 패턴 검색 알고리즘(Brute Force)

* 문자열을 처음부터 끝까지 차례로 순화하면서 패턴 내의 문자들을 일일이 비교하는 방식.

* 같으면 인덱스를 1씩 증가시키고 같지 않으면 i는 i-j로 비교시작위치로, j는 -1로.
  * 1씩 더해 다음엔 i는 최초위치 +1, j는 다시 0에서 시작. 
    * 찾을 패턴의 길이까지 j가 증가하는 데 성공하면 검색 성공! return i - M

* 시간복잡도: 최악의 경우 텍스트의 모든 위치에서 패턴 비교, O(MN)

#### 2) KMP 알고리즘

* 불일치가 발생한 앞 부분은 다시 비교하지 않고 매칭을 수행한다.
* 패턴을 전처리하여 배열 next[M]을 구해 잘못된 시작을 최소화함.
  * next[M]: 불일치가 발생한 경우 이동할 다음 위치
  * 해당 위치에서 잘렸을 때, 앞, 뒤를 비교, 같은 글자가 있는 구간의 글자수를 카운트.
* 시간복잡도: O(M+N) = O(N)
* 공유한 코드 잘 보고 이해하기.

#### 3) 보이어-무어 알고리즘

* 오른쪽에서 왼쪽으로 비교
* 대부분의 상용 소프트웨어에서 채택한 알고리즘
* 오른쪽 끝 문자가 불일치하고 이 문자가 패턴 내에 존재하지 않는 경우, 패턴의 길이만큼 이동한다.
* 오른쪽 끝 문자가 불일치하고 이 문자가 패턴 내에 존재하는 경우, 패턴에서 일치하는 문자(여러개일 경우 가장 오른쪽의 것)를 찾아 겹칠만큼 이동.
  * 예) 패턴 'abcde'의 경우, d, c, b, a에 대해 각각 1, 2, 3, 4만큼 skip. 해당 없으면 5 skip.
* 시간복잡도
  * 발상의 전환으로 패턴의 오른쪽부터 비교하여 텍스트 문자를 다 보지 않아도 된다.
  * 최악의 경우 O(MN)
  * 입력에 따라 다르지만, 일반적으로 O(N)보다 시간이 덜 든다.

### 3.3 문자열 암호화

* 시저 암호(Caesar cipher)
  * 평문에서 사용되고 있는 알파벳을 일정한 문자 수(키값)만큼 "평행이동"하여 암호화를 행한다.
* 단일 치환 암호
  * 문자 변환표를 이용한 암호화
  * 카이사르(시저) 암호화보다 훨씬 강력한 암호화 기법
  * 복호화를 위해서는 모든 키의 조합(key space)이 필요하다.
  * 순열로 풀어야 함. 알파벳 대문자에 한정해도 26! 1초에 10억 개씩 처리해도 120억 년 이상 소요.
* bit열의 암호화
  * 배타적 논리합(exclusive-or) 연산 사용
  * 같으면 0, 다르면 1
  * (&: 논리곱, |: 논리합, <<, >>, ^:배타적 논리합)
  * 암호화 키값과 복호화 키값이 같다.

### 3.4 문자열 압축

* Run-length encoding 알고리즘
* 같은 값이 몇 번 반복되는가를 나타내는 방법으로 압축
* 이미지 파일 중 BMP 파일포맷의 압축 방법
* 좀 더 효율적이고 일반적인 압축 방법: 허프만 코딩 알고리즘.

### 3.5 실습

* 회문
  * my) 세로 리스트 추가해서 반복문 한 번에 돌리면 되지 않을까. 발견하면 바로 탈출. 함수로 구현할까.
  * t) 원본 건드리지 않고 하나씩 읽으면서 flag 사용.
* 글자수
  * my) list, counting 기법 사용.
  * t) 문제에서 요구하는대로 dictionary 사용.
    * count = dict.fromkeys(str1, 0)
    * max(count.values())
* 회문2
  * m) 회문 문제처럼. 가장 긴 걸 찾아야 하므로 100부터 시작.
  * t) 이번에도 flag로.
* 9:56am, 제출 완료.