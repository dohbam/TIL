# 6. 큐(Queue)

### 1. 큐

* FIFO(Fisrt In First Out), 선입선출구조
* 큐의 선입선출구조
  * 삭제가 이루어지는 머리 (Front)
  * 마지막으로 저장된 원소 꼬리 (Rear)
* 큐의 기본 연산
  * 삽입: enQueue
  * 삭제: deQueue
* 큐의 주요 연산
  * enQueue(item): 큐의 뒤쪽(rear 다음)에 원소를 삽입
  * deQueue(): 큐의 앞쪽(front)에서 원소를 삭제하고 반환
    * 큐가 비어있는지 반드시 확인 후 실행
  * createQueue(): 공백 상태의 큐를 생성
  * isEmpty(): 큐가 공백상태인지 확인
  * isFull(): 큐가 포화상태인지 확인
    * 포화되지 않도록 충분히 크게 만들 것.
  * Qpeek(): 큐의 앞쪽(front)에서 원소를 삭제 없이 반환
* 큐의 연산 과정
  * 1) 공백 큐 생성: createQueue()
    * front = rear = -1
  * 2) 원소 A 삽입: enQueue(A)
    * front = -1
    * rear -> A
  * 3) 원소 B 삽입: enQueue(B)
    * front = -1
    * rear -> B
  * 4) 원소 반환/삭제: deQueue()
    * front -> A가 나간 자리
    * rear -> B
  * 5) 원소 C 삽입: enQueue(C)
    * front - 동일
    * rear -> C
  * 6) 원소 반환/삭제: deQueue()
    * front -> B가 나간 자리
    * rear -> C
  * 7) 원소 반환/삭제: deQueue()
    * front == rear == C가 있었던 자리.
    * 큐가 비어있다.
* 큐의 구현
  * 선형큐
    * 1차원 배열을 이용한 큐
      * 큐의 크기 == 배열의 크기
      * front: 저장된 첫 번째 원소의 인덱스
      * rear: 저장된 마지막 원소의 인덱스
    * 상태 표현
      * 초기 상태: front = rear = -1
      * 공백 상태: front = rear
      * 포화 상태: rear = n-1 (n: 배열의 크기, n-1: 배열의 마지막 인덱스)
  * 초기 공백 큐 생성
    - 크기 n인 1차원 배열 생성
    - front와 rear를 -1로 초기화
  * 삽입, 삭제, 공백 및 포화 검사, 검색.
  * Python에서는 그냥 list를 사용하면 됨.
    * append(A), pop(0)
    * Queue를 import 해서 쓸 수도 있음. put(A), get().
* 선형 큐 이용시 문제점: 잘못된 포화상태 인식
  * 해결방법 1) 연산시 저장된 원소들을 배열의 앞으로 모두 이동
    * -> 큐 효율성 급감
  * 해결방법 2) 원형 큐 이용.
* 원형 큐의 구조
  * 초기 공백 상태: front = rear = 0
  * index의 순환
    * front와 rear의 위치가 배열의 마지막 인덱스인 n-1을 가리킨 후, 그 다음에는 배열의 처음 인덱스인 0으로 이동
    * mod 사용
  * 공백과 포화 상태 구분을 쉽게 하기 위해 front가 있는 자리는 항상 빈자리로 둔다.
  * 삽입 위치 및 삭제 위치
    * 선형 큐 - 삽입: rear = rear + 1 / 삭제: front = front +1
    * 원형 큐 - 삽입: rear = (rear+1) mod n / 삭제: front = (front+1) mod n
  * 공백 및 포화상태 검사
    * 공백상태: front == rear
    * 포화상태: 삽입할 rear의 다음 위치 == 현재 front
      * (rear + 1) mod n == front
  * 구현
    * python: mod -> %
* 연결 큐의 구조
  * 단순 연결 리스트(Linked List)를 이용한 큐
    * 큐의 원소: 단순 연결 리스트의 노드
    * 큐의 원소 순서: 노드의 연결 순서. 링크로 연결.
    * front: 첫 번째 노드를 가리키는 링크
    * rear: 마지막 노드를 가리키는 링크
  * 상태 표현
    * 초기 상태: front == rear == null
    * 공백 상태: front == rear == null
* 연결 큐의 구현: *생략*

### 2. 우선순위 큐 (Priority Queue)

* 우선순위 큐의 특성
  * 우선순위를 가진 항목들을 저장하는 큐
  * FIFO 순서가 아니라, 우선순위가 높은 순서대로 먼저 나간다
* 우선순위 큐의 적용 분야
  * 시뮬레이션 시스템
  * 네트워크 트래픽 제어
  * 운영체제의 테스크 스케줄링
    * CPU는 한 번에 한 가지 일밖에 못함.
    * 아주 짧은 시간으로 교대 -> 우리 눈에는 멀티태스킹으로 보임.
    * 다중 CPU - 여러 개의 CPU로 병렬 처리
      * 2개 -> 1.3배 정도 속도 개선
* 우선순위 큐의 구현
  * 배열을 이용한 우선순위 큐
    * 배열을 이용하여 자료 저장
    * 원소 삽입 시 우선순위 비교하여 적절한 위치에 삽입 (삽입정렬)
    * 가장 앞: 최고 우선순위 원소
    * 문제점 -> 배열을 사용하여 삽입이나 삭제 연산 시 원소 재배치 발생
      * -> 시간, 메모리 낭비가 크다.
  * 리스트를 이용한 우선순위 큐
* 우선순위 큐의 기본 연산
  * 삽입: enQueue
  * 삭제: deQueue

### 3. 큐의 활용: 버퍼

* 버퍼
  * 데이터를 한 곳에서 다른 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리 영역.
  * 버퍼링: 버퍼를 활용하는 방식 또는 버퍼를 채우는 동작을 의미
* 버퍼의 자료 구조
  * 버퍼는 일반적으로 입출력 및 네트워크 관련 기능에서 이용
  * 순서대로 입력/출력/전달되어야 하므로 FIFO 방식의 자료구조인 큐를 활용

### 4. BFS (Breadth First Search)

* 그래프를 탐색하는 방법

  * 깊이 우선 탐색(Depth First Search, DFS)
  * 너비 우선 탐색(Breadth First Search, BFS)

* 너비우선탐색

  * 탐색 시작점의 인접한 정점들을 모두 차례로 방문
  * 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문
  * -> 선입선출 형태의 자료구조인 큐 활용

* BFS 알고리즘

  * BFS(G, v): # 그래프 G, 탐색 시작점 v
  * 반복 DFS 알고리즘과 유사
    * while queue: <- 반복문 들어가기 전에 삽입
    * queue에서 뺄 때, visited check 후 작업 수행
    * queue에 넣을 때 방문 처리하는 방법도 있음 -> 두 번째 방문체크를 안 해도 되지.

  ```python
  def BFS(G, v): # 그래프 G, 탐색 시작점 v
      visited = [0]*n # n: 정점의 개수
      queue = [] # 큐 생성
      queue.append(v) # 시작점 v 큐에 삽입
      while queue: # 큐가 비어있지 않을 때
          t = queue.pop(0) # 큐의 첫 번째 원소 반환
          if not visited[t]:
              visited = True # 방문 체크
              visit(t) # 작업 수행
          for i in G(t): # t와 연결된 모든 선에 대해
              if not visited[i]: # 방문되지 않은 곳이라면
                  queue.append(i) # 큐에 넣는다.
  ```

  * 시작 정점과의 거리를 재야 한다면
    * enQueue할 때 visited 체크, 작업 수행 -> 더 많이 사용.

### 5. 최단경로



### 6. 실습 1, 2

* 실습, 연습 선생님 답 꼭 보기
* 행렬찾기
  * 방법1: 탐색, 정렬
  * 방법2: lamda 이용 콜백함수
  * 방법3: 곱, 행, 열로 저장 -> sort()로 sorting 가능.

